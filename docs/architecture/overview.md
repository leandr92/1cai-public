# Обзор архитектуры CursorExt

## Цель решения

CursorExt предназначен для хранения и синхронизации «коллективной памяти» агентов и разработчиков. Система должна собирать хронологию действий в IDE, фильтровать чувствительные данные и реплицировать события в общее GitHub-хранилище.

## Компоненты

- **Core-плагин IDE** — отслеживает действия пользователя, формирует события и управляет локальным кешем.
- **Локальное хранилище** — буфер событий (SQLite/LevelDB), обеспечивающий офлайн-работу и временное хранение.
- **Адаптер синхронизации** — отвечает за упаковку событий и их публикацию в наружное хранилище (например, отдельный GitHub-репозиторий memory-store).
- **Интерфейс просмотра** — web-view внутри IDE, позволяющий просматривать, фильтровать и экспортировать события.
- **Интеграции с агентами/CI** — CLI-инструменты и webhooks для headless-агентов и пайплайнов, синхронизирующих результаты.

## Поток данных

1. IDE генерирует события (открытие файла, успешный тест, заметка агента).
2. Core-плагин проводит первичную фильтрацию: удаление секретов, приватных путей, больших двоичных артефактов.
3. События сохраняются в локальный кеш.
4. Адаптер синхронизации батчит новые записи и публикует их в выбранное наружное хранилище.
5. Интерфейс просмотра и CLI читают находящиеся в GitHub данные и представляют их пользователю.

## Требования к безопасности и качеству

- Детектировать и маскировать секреты до синхронизации.
- Поддерживать ручное подтверждение перед публикацией потенциально чувствительных событий.
- Обеспечить верификацию целостности (хэширование батчей, подписи).
- Логировать ошибки синхронизации и предоставлять механизмы восстановления.

## Следующие шаги

- Уточнить формат событий (JSON Schema) и контракт адаптера.
- Выбрать технологию локального кеша и реализовать прототип логгера (этап 0).
- Проработать стратегию миграции исторических данных.

