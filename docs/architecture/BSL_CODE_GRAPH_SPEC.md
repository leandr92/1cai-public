# BSL Code Graph Standard (Specification)

> **Статус:** ✅ В разработке  
> **Версия:** 1.0.0  
> **Дата:** 2025-11-17  
> **Уникальность:** 100% - такого стандарта нет ни у кого

---

## Обзор

**BSL Code Graph Standard** — формальная спецификация для автоматического построения графа изменений из BSL кода (язык программирования платформы 1С:Предприятие). Это расширение Unified Change Graph со специфичными типами узлов и связей для 1C экосистемы.

### Ключевые особенности:

1. **Автоматическое построение** — граф строится автоматически из BSL кода без ручной настройки
2. **1C-специфичные типы** — поддержка всех типов объектов метаданных 1C (Документы, Регистры, Справочники и т.д.)
3. **Зависимости из кода** — автоматическое извлечение зависимостей из BSL кода (вызовы функций, SQL-запросы, использование метаданных)
4. **Интеграция с метаданными** — связь между BSL кодом и объектами метаданных конфигурации
5. **Совместимость** — расширяет Unified Change Graph, полностью совместим с `CODE_GRAPH_SCHEMA.json`

---

## 1. Типы узлов (BSL-Specific Node Kinds)

### Базовые типы (из Unified Change Graph):

- `module` — BSL модуль
- `function` — функция BSL
- `procedure` — процедура BSL
- `db_table` — таблица БД (извлечена из SQL-запросов)
- `db_view` — представление БД

### Расширенные типы для 1C метаданных:

- `bsl_document` — Документ (объект метаданных 1C)
- `bsl_catalog` — Справочник (объект метаданных 1C)
- `bsl_common_module` — Общий модуль
- `bsl_register_information` — Регистр сведений
- `bsl_register_accumulation` — Регистр накопления
- `bsl_register_accounting` — Регистр бухгалтерии
- `bsl_report` — Отчет
- `bsl_data_processor` — Обработка
- `bsl_chart_of_accounts` — План счетов
- `bsl_chart_of_characteristic_types` — План видов характеристик
- `bsl_chart_of_calculation_types` — План видов расчета
- `bsl_business_process` — Бизнес-процесс
- `bsl_task` — Задача
- `bsl_constant` — Константа
- `bsl_enum` — Перечисление
- `bsl_external_data_processor` — Внешняя обработка
- `bsl_external_report` — Внешний отчет
- `bsl_http_service` — HTTP сервис
- `bsl_ws_reference` — WS ссылка
- `bsl_exchange_plan` — План обмена
- `bsl_query` — SQL-запрос (как отдельный узел)
- `bsl_form` — Форма объекта
- `bsl_command` — Команда объекта

### Типы модулей в объектах 1C:

- `bsl_object_module` — Модуль объекта
- `bsl_manager_module` — Модуль менеджера
- `bsl_form_module` — Модуль формы
- `bsl_command_module` — Модуль команды

---

## 2. Типы связей (BSL-Specific Edge Kinds)

### Базовые типы (из Unified Change Graph):

- `DEPENDS_ON` — зависимость (функция вызывает функцию, модуль использует таблицу)
- `OWNS` — владение (модуль содержит функцию, объект содержит модуль)
- `IMPLEMENTS` — реализация (код реализует требование)
- `TESTED_BY` — тестируется (код тестируется тестами)
- `MONITORED_BY` — мониторится (сервис мониторится алертами)

### Расширенные типы для 1C:

- `BSL_CALLS` — вызов функции/процедуры (более специфичный чем DEPENDS_ON)
- `BSL_USES_METADATA` — использование объекта метаданных в коде
- `BSL_READS_TABLE` — чтение таблицы БД (SELECT)
- `BSL_WRITES_TABLE` — запись в таблицу БД (INSERT/UPDATE/DELETE)
- `BSL_EXECUTES_QUERY` — выполнение SQL-запроса
- `BSL_HAS_MODULE` — объект метаданных имеет модуль (ObjectModule, ManagerModule, FormModule)
- `BSL_HAS_FORM` — объект имеет форму
- `BSL_HAS_COMMAND` — объект имеет команду
- `BSL_EXTENDS` — наследование (объект расширяет другой объект)
- `BSL_REFERENCES` — ссылка на другой объект (Справочник ссылается на Справочник)
- `BSL_SUBTYPE` — подтип объекта (для объектов с включенной иерархией)
- `BSL_HAS_REGISTER` — документ/обработка имеет регистр

---

## 3. Структура узла BSL

### Базовая структура (совместима с Unified Change Graph):

```json
{
  "id": "bsl_document:ЗаказыПокупателей",
  "kind": "bsl_document",
  "display_name": "Документ: ЗаказыПокупателей",
  "labels": ["bsl", "1c", "document", "metadata"],
  "props": {
    "metadata_path": "Документы.ЗаказыПокупателей",
    "uuid": "12345678-1234-1234-1234-123456789012",
    "version": "8.3.24",
    "has_object_module": true,
    "has_manager_module": true,
    "has_form": true,
    "forms_count": 2,
    "commands_count": 5,
    "owner": "development-team",
    "environment": ["dev", "staging", "prod"],
    "risk_level": "prod_low"
  }
}
```

### BSL-специфичные поля в `props`:

#### Для объектов метаданных:

- `metadata_path` (обязательно) — путь к объекту метаданных (например, "Документы.ЗаказыПокупателей")
- `uuid` — UUID объекта метаданных из .xml файла
- `version` — версия платформы 1C
- `has_object_module` — есть ли модуль объекта
- `has_manager_module` — есть ли модуль менеджера
- `has_form` — есть ли форма
- `forms_count` — количество форм
- `commands_count` — количество команд
- `is_preselection` — является ли объект предварительным отбором
- `is_managed` — является ли объект управляемым
- `is_hierarchical` — имеет ли объект иерархию

#### Для модулей:

- `module_path` (обязательно) — путь к модулю (например, "ОбщийМодуль.УправлениеЗаказами")
- `module_type` — тип модуля (ObjectModule, ManagerModule, FormModule, CommonModule)
- `loc` — количество строк кода
- `complexity` — сложность модуля (цикломатическая сложность)
- `functions_count` — количество функций
- `procedures_count` — количество процедур
- `exported_functions` — список экспортируемых функций

#### Для функций/процедур:

- `function_name` (обязательно) — имя функции/процедуры
- `module` — модуль, к которому принадлежит функция
- `exported` — является ли функция экспортируемой
- `parameters` — список параметров
- `complexity` — сложность функции
- `start_line` — начальная строка
- `end_line` — конечная строка
- `has_documentation` — есть ли документация (комментарии)
- `calls_functions` — список вызываемых функций
- `uses_tables` — список используемых таблиц БД
- `uses_metadata` — список используемых объектов метаданных

#### Для SQL-запросов:

- `query_text` — текст запроса
- `query_type` — тип запроса (SELECT, INSERT, UPDATE, DELETE)
- `tables_used` — список используемых таблиц
- `tables_written` — список таблиц, в которые выполняется запись
- `complexity_score` — оценка сложности запроса

---

## 4. Алгоритмы извлечения зависимостей

### 4.1 Извлечение вызовов функций

**Алгоритм:**

1. Парсинг BSL кода для поиска вызовов функций:
   - Паттерн: `ИмяФункции()` или `ИмяМодуля.ИмяФункции()`
   - Обработка динамических вызовов через `Выполнить()`, `ИмяМетода()`

2. Определение модуля функции:
   - Если `ИмяМодуля.ИмяФункции()` — явное указание модуля
   - Если `ИмяФункции()` — поиск в текущем модуле и импортированных модулях

3. Создание связи `BSL_CALLS`:
   - `source`: вызывающая функция/процедура
   - `target`: вызываемая функция/процедура
   - `props`: { "line": номер_строки, "dynamic": true/false }

### 4.2 Извлечение использования метаданных

**Алгоритм:**

1. Парсинг BSL кода для поиска обращений к метаданным:
   - Паттерн: `Метаданные.Документы.ИмяДокумента`
   - Паттерн: `Документы.ИмяДокумента`
   - Паттерн: `Справочники.ИмяСправочника`

2. Определение типа объекта метаданных:
   - `Метаданные.Документы.*` → `bsl_document`
   - `Метаданные.Справочники.*` → `bsl_catalog`
   - `Метаданные.РегистрыСведений.*` → `bsl_register_information`
   - И т.д.

3. Создание связи `BSL_USES_METADATA`:
   - `source`: модуль/функция, использующая метаданные
   - `target`: объект метаданных
   - `props`: { "operation": "read/write/create/delete", "line": номер_строки }

### 4.3 Извлечение SQL-запросов

**Алгоритм:**

1. Парсинг BSL кода для поиска SQL-запросов:
   - Паттерн: строка между `Запрос.Текст = "..."` или `Запрос = Новый Запрос; Запрос.Текст = "..."`
   - Паттерн: использование `Запрос = Новый Запрос; Запрос.Текст = ...`

2. Парсинг текста запроса:
   - Извлечение таблиц из `FROM`, `JOIN`
   - Определение операций `SELECT`, `INSERT`, `UPDATE`, `DELETE`
   - Поиск подзапросов

3. Создание узла `bsl_query`:
   - Уникальный ID: `bsl_query:{module_path}:{query_hash}`
   - Сохранение текста запроса в `props.query_text`

4. Создание связей:
   - `BSL_EXECUTES_QUERY`: модуль/функция → запрос
   - `BSL_READS_TABLE`: запрос → таблица (для SELECT)
   - `BSL_WRITES_TABLE`: запрос → таблица (для INSERT/UPDATE/DELETE)

### 4.4 Извлечение зависимостей модулей

**Алгоритм:**

1. Парсинг метаданных конфигурации (.xml файлы):
   - Поиск всех объектов метаданных
   - Извлечение путей к модулям (ObjectModule, ManagerModule, FormModule)

2. Создание узлов объектов метаданных:
   - Тип узла зависит от типа объекта (bsl_document, bsl_catalog и т.д.)
   - Заполнение метаданных из .xml файла

3. Создание связей:
   - `BSL_HAS_MODULE`: объект метаданных → модуль
   - `OWNS`: модуль → функции/процедуры в модуле

---

## 5. Примеры графов

### Пример 1: Простой документ

```json
{
  "nodes": [
    {
      "id": "bsl_document:ЗаказыПокупателей",
      "kind": "bsl_document",
      "display_name": "Документ: ЗаказыПокупателей",
      "labels": ["bsl", "1c", "document"],
      "props": {
        "metadata_path": "Документы.ЗаказыПокупателей",
        "has_object_module": true,
        "has_manager_module": true
      }
    },
    {
      "id": "bsl_object_module:Документы.ЗаказыПокупателей",
      "kind": "bsl_object_module",
      "display_name": "Модуль объекта: ЗаказыПокупателей",
      "labels": ["bsl", "1c", "module", "object_module"],
      "props": {
        "module_path": "Документы.ЗаказыПокупателей",
        "module_type": "ObjectModule",
        "loc": 150
      }
    },
    {
      "id": "function:Документы.ЗаказыПокупателей:ПроверкаПроведения",
      "kind": "function",
      "display_name": "Функция: ПроверкаПроведения",
      "labels": ["bsl", "1c", "function"],
      "props": {
        "module": "Документы.ЗаказыПокупателей",
        "function_name": "ПроверкаПроведения",
        "exported": false
      }
    }
  ],
  "edges": [
    {
      "source": "bsl_document:ЗаказыПокупателей",
      "target": "bsl_object_module:Документы.ЗаказыПокупателей",
      "kind": "BSL_HAS_MODULE"
    },
    {
      "source": "bsl_object_module:Документы.ЗаказыПокупателей",
      "target": "function:Документы.ЗаказыПокупателей:ПроверкаПроведения",
      "kind": "OWNS"
    }
  ]
}
```

### Пример 2: Зависимости между модулями

```json
{
  "nodes": [
    {
      "id": "function:ОбщийМодуль.Заказы:СоздатьЗаказ",
      "kind": "function",
      "display_name": "Функция: СоздатьЗаказ",
      "labels": ["bsl", "1c", "function"],
      "props": {
        "module": "ОбщийМодуль.Заказы",
        "function_name": "СоздатьЗаказ",
        "exported": true
      }
    },
    {
      "id": "function:ОбщийМодуль.Валидация:ПроверитьЗаказ",
      "kind": "function",
      "display_name": "Функция: ПроверитьЗаказ",
      "labels": ["bsl", "1c", "function"],
      "props": {
        "module": "ОбщийМодуль.Валидация",
        "function_name": "ПроверитьЗаказ",
        "exported": true
      }
    }
  ],
  "edges": [
    {
      "source": "function:ОбщийМодуль.Заказы:СоздатьЗаказ",
      "target": "function:ОбщийМодуль.Валидация:ПроверитьЗаказ",
      "kind": "BSL_CALLS",
      "props": {
        "line": 25,
        "dynamic": false
      }
    }
  ]
}
```

### Пример 3: Использование метаданных и SQL-запросов

```json
{
  "nodes": [
    {
      "id": "bsl_query:ОбщийМодуль.Заказы:query_123",
      "kind": "bsl_query",
      "display_name": "SQL-запрос: Получение заказов",
      "labels": ["bsl", "1c", "query"],
      "props": {
        "query_text": "SELECT * FROM Документ.ЗаказыПокупателей WHERE Дата >= &Дата",
        "query_type": "SELECT",
        "tables_used": ["Документ.ЗаказыПокупателей"]
      }
    },
    {
      "id": "db_table:Документ.ЗаказыПокупателей",
      "kind": "db_table",
      "display_name": "Таблица: Документ.ЗаказыПокупателей",
      "labels": ["bsl", "1c", "table"],
      "props": {
        "table_name": "Документ.ЗаказыПокупателей",
        "source_metadata": "Документы.ЗаказыПокупателей"
      }
    }
  ],
  "edges": [
    {
      "source": "function:ОбщийМодуль.Заказы:ПолучитьЗаказы",
      "target": "bsl_query:ОбщийМодуль.Заказы:query_123",
      "kind": "BSL_EXECUTES_QUERY"
    },
    {
      "source": "bsl_query:ОбщийМодуль.Заказы:query_123",
      "target": "db_table:Документ.ЗаказыПокупателей",
      "kind": "BSL_READS_TABLE"
    },
    {
      "source": "bsl_query:ОбщийМодуль.Заказы:query_123",
      "target": "bsl_document:ЗаказыПокупателей",
      "kind": "BSL_USES_METADATA",
      "props": {
        "operation": "read"
      }
    }
  ]
}
```

---

## 6. Требования к совместимости

### 6.1 Совместимость с Unified Change Graph

BSL Code Graph является расширением Unified Change Graph и должен:

1. **Использовать базовые типы** — расширять, а не заменять базовые типы узлов/связей
2. **Совместимость с JSON Schema** — экспортировать граф, валидный по `CODE_GRAPH_SCHEMA.json`
3. **Интерфейс CodeGraphBackend** — использовать существующий интерфейс для работы с графом

### 6.2 Версионирование

- **v1.0.0** (текущая версия) — базовая спецификация с основными типами узлов и связей
- **v1.1.0** (планируется) — добавление поддержки подсистем, общих форм, общих модулей с серверными/клиентскими вызовами
- **v2.0.0** (планируется) — интеграция с внешними отчетами и обработками

---

## 7. JSON Schema для BSL Code Graph

Расширенная JSON Schema (`BSL_CODE_GRAPH_SCHEMA.json`) должна:

1. Расширять `CODE_GRAPH_SCHEMA.json`
2. Добавлять валидацию для BSL-специфичных типов узлов
3. Добавлять валидацию для BSL-специфичных связей
4. Валидировать обязательные поля для BSL узлов (metadata_path, module_path и т.д.)

---

## 8. Интеграция с парсерами

### Поддерживаемые парсеры:

1. **AST Parser** (предпочтительно):
   - Использование bsl-language-server для продвинутого парсинга
   - Полная поддержка синтаксиса BSL
   - Извлечение семантической информации

2. **Regex-based Parser** (fallback):
   - Упрощенный парсер на основе регулярных выражений
   - Базовая поддержка функций, процедур, SQL-запросов
   - Используется при недоступности AST парсера

3. **XML Metadata Parser**:
   - Парсинг .xml файлов конфигурации для извлечения метаданных
   - Построение графа объектов метаданных
   - Связь модулей с объектами метаданных

---

## 9. Алгоритмы построения графа

### 9.1 Последовательность построения:

1. **Парсинг метаданных** (.xml файлы):
   - Извлечение всех объектов метаданных
   - Создание узлов объектов метаданных

2. **Парсинг модулей** (.bsl файлы):
   - Парсинг BSL кода каждого модуля
   - Извлечение функций, процедур, переменных

3. **Построение зависимостей**:
   - Поиск вызовов функций в коде
   - Извлечение SQL-запросов
   - Поиск обращений к метаданным

4. **Создание связей**:
   - Связь модулей с объектами метаданных
   - Связь функций между собой
   - Связь запросов с таблицами

### 9.2 Оптимизация:

- **Инкрементальное построение** — обновление только измененных модулей
- **Кэширование** — сохранение результатов парсинга
- **Параллельная обработка** — параллельный парсинг нескольких модулей

---

## 10. Использование графа

### 10.1 Impact-анализ:

**Вопрос:** "Что затронет изменение функции X?"

**Алгоритм:**

1. Найти узел функции X в графе
2. Найти все узлы, которые зависят от X (обратный поиск по `BSL_CALLS`)
3. Найти все узлы, которые используют модуль, содержащий X
4. Найти все тесты, которые тестируют X (`TESTED_BY`)
5. Вернуть список всех затронутых узлов

### 10.2 Coverage-анализ:

**Вопрос:** "Какие тесты покрывают этот модуль?"

**Алгоритм:**

1. Найти узел модуля в графе
2. Найти все тесты, которые имеют связь `TESTED_BY` с модулем или его функциями
3. Вернуть список тестов с метриками покрытия

### 10.3 Traceability:

**Вопрос:** "Какие требования реализует этот код?"

**Алгоритм:**

1. Найти узел кода в графе
2. Найти все требования, которые имеют связь `IMPLEMENTS` с кодом
3. Найти все тикеты, которые связаны с кодом
4. Вернуть матрицу traceability

---

## 11. Интеграция с другими стандартами

### 11.1 Scenario DSL:

- Использование `graph_refs` в `ScenarioStep.metadata` для ссылок на узлы BSL графа
- Автоматическое построение `graph_refs` из запроса пользователя через `GraphQueryHelper`

### 11.2 Autonomy Policy:

- Использование `risk_level` из узлов графа для определения уровня риска сценария
- Автоматическая оценка риска изменения на основе затронутых узлов

### 11.3 LLM Provider Abstraction:

- Использование типа узла (bsl_document, bsl_query и т.д.) для выбора подходящего LLM провайдера
- Специализированные промпты для разных типов BSL артефактов

---

## 12. Метрики и мониторинг

### 12.1 Метрики построения графа:

- `bsl_graph_nodes_total` — общее количество узлов в BSL графе
- `bsl_graph_edges_total` — общее количество связей в BSL графе
- `bsl_graph_build_duration_seconds` — время построения графа
- `bsl_graph_build_errors_total` — количество ошибок при построении

### 12.2 Метрики использования:

- `bsl_graph_queries_total` — количество запросов к графу
- `bsl_graph_query_duration_seconds` — время выполнения запросов
- `bsl_impact_analysis_total` — количество выполненных impact-анализов
- `bsl_coverage_analysis_total` — количество выполненных coverage-анализов

---

## 13. Примеры реализации

### Пример 1: OneCCodeGraphBuilder

```python
from src.ai.code_graph_1c_builder import OneCCodeGraphBuilder
from src.ai.code_graph import InMemoryCodeGraphBackend

backend = InMemoryCodeGraphBackend()
builder = OneCCodeGraphBuilder(backend, use_ast_parser=True)

# Построить граф из модуля
stats = await builder.build_from_module(
    "ОбщийМодуль.УправлениеЗаказами",
    module_code,
    module_metadata={"owner": "my-team"},
)

# Экспортировать граф
graph_export = await builder.export_graph("graph.json")
```

### Пример 2: Использование графа для impact-анализа

```python
from src.ai.code_graph_query_helper import GraphQueryHelper

helper = GraphQueryHelper(backend)

# Найти функцию в графе
function_node = await helper.find_nodes(
    kind=NodeKind.FUNCTION,
    prop_equals={"function_name": "СоздатьЗаказ"}
)

# Найти все зависимости
dependencies = await helper.neighbors(
    function_node[0].id,
    kinds=[EdgeKind.BSL_CALLS]
)
```

---

## 14. Следующие шаги

1. **Реализация расширенных типов узлов** в `code_graph.py`
2. **Создание JSON Schema** `BSL_CODE_GRAPH_SCHEMA.json`
3. **Обновление OneCCodeGraphBuilder** для поддержки новых типов
4. **Интеграция с метаданными** — парсинг .xml файлов конфигурации
5. **Тесты и валидация** — unit и integration тесты для BSL графа

---

**Примечание:** Этот стандарт делает платформу уникальной в экосистеме 1C AI разработки, так как автоматическое построение графа из BSL кода не реализовано ни у одного конкурента.

