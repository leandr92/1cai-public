from __future__ import annotations

import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional


def load_records(base_dir: Path, collector: str) -> Iterable[Dict]:
    collector_dir = base_dir / collector
    if not collector_dir.exists():
        return []
    dated_dirs = sorted([p for p in collector_dir.iterdir() if p.is_dir()], reverse=True)
    for dated in dated_dirs:
        for json_file in sorted(dated.glob("*.json"), reverse=True):
            try:
                payload = json.loads(json_file.read_text(encoding="utf-8"))
                yield from payload.get("records", [])
            except (json.JSONDecodeError, OSError):
                continue
        break


def build_scenario_catalog(job_records: Iterable[Dict], usage_records: Iterable[Dict]) -> Dict[str, object]:
    tracks: Dict[str, Dict[str, object]] = {}
    for record in job_records:
        domain = record.get("platform", "general")
        track = tracks.setdefault(
            domain,
            {
                "domain": domain,
                "skills": set(),
                "scenarios": [],
            },
        )
        track["skills"].update(record.get("skills", []))
    for record in usage_records:
        feature = record.get("feature", "")
        if feature.startswith("discovery"):
            track = tracks.setdefault(
                "internal",
                {
                    "domain": "internal",
                    "skills": set(),
                    "scenarios": [],
                },
            )
            track["scenarios"].append({"feature": feature, "timestamp": record.get("timestamp")})
    # convert sets
    catalog = []
    for data in tracks.values():
        catalog.append(
            {
                "domain": data["domain"],
                "skills": sorted(data["skills"]),
                "scenarios": data["scenarios"],
            }
        )
    return {
        "generated_at": datetime.utcnow().isoformat() + "Z",
        "tracks": sorted(catalog, key=lambda item: item["domain"]),
    }


def sync_templates(
    *,
    input_dir: Path,
    template_path: Path,
    catalog_output: Path,
) -> None:
    job_records = list(load_records(input_dir, "job_market"))
    usage_records = list(load_records(input_dir, "internal_usage"))
    catalog = build_scenario_catalog(job_records, usage_records)

    catalog_output.parent.mkdir(parents=True, exist_ok=True)
    catalog_output.write_text(json.dumps(catalog, ensure_ascii=False, indent=2), encoding="utf-8")

    template = template_path.read_text(encoding="utf-8") if template_path.exists() else ""
    status_section = "\n".join(
        [
            "<!-- autogenerated: scenario stats -->",
            f"Последнее обновление: {catalog['generated_at']}",
            f"Доступные домены: {', '.join(track['domain'] for track in catalog['tracks'])}",
            "<!-- end autogenerated -->",
        ]
    )
    if "<!-- autogenerated: scenario stats -->" in template:
        pre, _sep, _tail = template.partition("<!-- autogenerated: scenario stats -->")
        _prev_section, _sep2, rest = template.partition("<!-- end autogenerated -->")
        new_content = pre + status_section + rest[rest.find("\n") :]
    else:
        new_content = template.rstrip() + "\n\n" + status_section + "\n"
    template_path.write_text(new_content, encoding="utf-8")


def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Sync BA scenario templates with latest data.")
    parser.add_argument("--input-dir", default="data/ba_intel", help="Каталог snapshots (по умолчанию data/ba_intel)")
    parser.add_argument(
        "--template",
        default="templates/ba/discovery_process_bi_template.md",
        help="Путь к основному шаблону сценария",
    )
    parser.add_argument(
        "--catalog-output",
        default="templates/ba/generated/scenario_catalog.json",
        help="Файл для выгрузки каталога сценариев",
    )
    return parser.parse_args(argv)


def main(argv: Optional[List[str]] = None) -> None:
    args = parse_args(argv)
    sync_templates(
        input_dir=Path(args.input_dir),
        template_path=Path(args.template),
        catalog_output=Path(args.catalog_output),
    )


if __name__ == "__main__":  # pragma: no cover
    main()

