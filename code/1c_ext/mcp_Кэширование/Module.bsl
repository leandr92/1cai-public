#Область ПрограммныйИнтерфейс

// Устанавливает значение в кэш с указанным ключом и TTL
// 
// Параметры:
//   Ключ - Строка - Уникальный ключ для доступа к кэшируемым данным
//   Значение - Произвольный - Данные для кэширования (сериализуемые в JSON)
//   ВремяЖизни - Число - Время жизни кэша в секундах (по умолчанию 3600 = 1 час)
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//   Контекст - Строка - Контекст кэширования (например, "метаданные", "результат_запроса")
//
// Возвращаемое значение:
//   Булево - Истина, если значение успешно сохранено в кэш
//
Функция УстановитьВКэш(Ключ, Значение, ВремяЖизни = 3600, ИдентификаторЗапроса = "", Контекст = "") Экспорт
	
	ЗаписатьЛог("INFO", "Установка в кэш", ИдентификаторЗапроса, Ключ, Контекст);
	
	Попытка
		СтруктураКэша = Новый Структура;
		СтруктураКэша.Вставить("Значение", Значение);
		СтруктураКэша.Вставить("ВремяСоздания", ТекущаяУниверсальнаяДатаВМиллисекундах());
		СтруктураКэша.Вставить("ВремяЖизни", ВремяЖизни);
		СтруктураКэша.Вставить("Контекст", Контекст);
		
		ХэшКлюча = ПолучитьХэшКлюча(Ключ);
		СериализованноеЗначение = mcp_ОбщегоНазначения.СтруктураВJSON(СтруктураКэша);
		
		ГлобальныйКэш.Вставить(ХэшКлюча, СериализованноеЗначение);
		
		ЗаписатьЛог("DEBUG", "Значение установлено в кэш", ИдентификаторЗапроса, Ключ, Контекст);
		Возврат Истина;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка установки в кэш", ИдентификаторЗапроса, Ключ, Контекст);
		ОбработатьОшибку("mcp_Кэширование.УстановитьВКэш", ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Получает значение из кэша по ключу
// 
// Параметры:
//   Ключ - Строка - Ключ кэшируемых данных
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   Произвольный - Данные из кэша или Неопределено, если ключ не найден или истек
//
Функция ПолучитьИзКэша(Ключ, ИдентификаторЗапроса = "") Экспорт
	
	ХэшКлюча = ПолучитьХэшКлюча(Ключ);
	ЗаписатьЛог("DEBUG", "Получение из кэша", ИдентификаторЗапроса, Ключ, "");
	
	Попытка
		
		СериализованноеЗначение = ГлобальныйКэш.Получить(ХэшКлюча);
		
		Если СериализованноеЗначение = Неопределено Тогда
			ЗаписатьЛог("DEBUG", "Ключ не найден в кэше", ИдентификаторЗапроса, Ключ, "");
			Возврат Неопределено;
		КонецЕсли;
		
		СтруктураКэша = mcp_ОбщегоНазначения.JSONВСтруктуру(СериализованноеЗначение);
		
		ВремяТекущее = ТекущаяУниверсальнаяДатаВМиллисекундах();
		ВремяСоздания = СтруктураКэша.ВремяСоздания;
		ВремяЖизни = СтруктураКэша.ВремяЖизни;
		
		Если (ВремяТекущее - ВремяСоздания) > (ВремяЖизни * 1000) Тогда
			// Кэш истек
			УдалитьИзКэша(Ключ);
			ЗаписатьЛог("DEBUG", "Кэш истек", ИдентификаторЗапроса, Ключ, "");
			Возврат Неопределено;
		КонецЕсли;
		
		ЗаписатьЛог("DEBUG", "Значение получено из кэша", ИдентификаторЗапроса, Ключ, СтруктураКэша.Контекст);
		Возврат СтруктураКэша.Значение;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка получения из кэша", ИдентификаторЗапроса, Ключ, "");
		ОбработатьОшибку("mcp_Кэширование.ПолучитьИзКэша", ИнформацияОбОшибке());
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Удаляет значение из кэша по ключу
// 
// Параметры:
//   Ключ - Строка - Ключ кэшируемых данных
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   Булево - Истина, если значение было удалено или отсутствовало
//
Функция УдалитьИзКэша(Ключ, ИдентификаторЗапроса = "") Экспорт
	
	ЗаписатьЛог("DEBUG", "Удаление из кэша", ИдентификаторЗапроса, Ключ, "");
	
	Попытка
		ХэшКлюча = ПолучитьХэшКлюча(Ключ);
		ГлобальныйКэш.Удалить(ХэшКлюча);
		ЗаписатьЛог("DEBUG", "Значение удалено из кэша", ИдентификаторЗапроса, Ключ, "");
		Возврат Истина;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка удаления из кэша", ИдентификаторЗапроса, Ключ, "");
		ОбработатьОшибку("mcp_Кэширование.УдалитьИзКэша", ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Очищает кэш полностью или по префиксу
// 
// Параметры:
//   Префикс - Строка - Префикс ключей для частичной очистки (по умолчанию очищается весь кэш)
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   Число - Количество удаленных записей
//
Функция ОчиститьКэш(Префикс = "", ИдентификаторЗапроса = "") Экспорт
	
	ЗаписатьЛог("INFO", "Очистка кэша", ИдентификаторЗапроса, Префикс, "");
	
	Попытка
		КоличествоУдаленных = 0;
		
		Если ПустаяСтрока(Префикс) Тогда
			// Очистка всего кэша
			ГлобальныйКэш.Очистить();
			КоличествоУдаленных = 1; // Весь кэш
		Иначе
			// Частичная очистка по префиксу
			КлючиКУдалению = Новый Массив;
			
			Для Каждого КлючЗначение Из ГлобальныйКэш Цикл
				Если Лев(КлючЗначение.Ключ, СтрДлина(Префикс)) = Префикс Тогда
					КлючиКУдалению.Добавить(КлючЗначение.Ключ);
				КонецЕсли;
			КонецЦикла;
			
			Для Каждого Ключ Из КлючиКУдалению Цикл
				ГлобальныйКэш.Удалить(Ключ);
				КоличествоУдаленных = КоличествоУдаленных + 1;
			КонецЦикла;
		КонецЕсли;
		
		ЗаписатьЛог("INFO", "Кэш очищен", ИдентификаторЗапроса, Префикс, "Удалено: " + КоличествоУдаленных);
		Возврат КоличествоУдаленных;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка очистки кэша", ИдентификаторЗапроса, Префикс, "");
		ОбработатьОшибку("mcp_Кэширование.ОчиститьКэш", ИнформацияОбОшибке());
		Возврат 0;
	КонецПопытки;
	
КонецФункции

// Получает метаданные конфигурации из кэша или создает новые
// 
// Параметры:
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   ТаблицаЗначений - Кэшированные метаданные конфигурации с TTL 1 час
//
Функция ПолучитьКэшМетаданныхКонфигурации(ИдентификаторЗапроса = "") Экспорт
	
	КлючКэша = "метаданные_конфигурации";
	ЗаписатьЛог("DEBUG", "Получение кэша метаданных", ИдентификаторЗапроса, КлючКэша, "");
	
	КэшированныеМетаданные = ПолучитьИзКэша(КлючКэша, ИдентификаторЗапроса);
	
	Если КэшированныеМетаданные <> Неопределено Тогда
		ЗаписатьЛог("DEBUG", "Метаданные получены из кэша", ИдентификаторЗапроса, КлючКэша, "");
		Возврат КэшированныеМетаданные;
	КонецЕсли;
	
	// Кэш истек или отсутствует, создаем новые метаданные
	ЗаписатьЛог("INFO", "Создание нового кэша метаданных", ИдентификаторЗапроса, КлючКэша, "");
	
	Попытка
		// Получаем метаданные через mcp_Метаданные
		Метаданные = mcp_КонтейнерыПнтИсп.Инструменты();
		
		// Сохраняем в кэш на 1 час (3600 секунд)
		УстановитьВКэш(КлючКэша, Метаданные, 3600, ИдентификаторЗапроса, "метаданные");
		
		ЗаписатьЛог("INFO", "Метаданные закэшированы", ИдентификаторЗапроса, КлючКэша, "");
		Возврат Метаданные;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка создания кэша метаданных", ИдентификаторЗапроса, КлючКэша, "");
		ОбработатьОшибку("mcp_Кэширование.ПолучитьКэшМетаданныхКонфигурации", ИнформацияОбОшибке());
		Возврат Новый ТаблицаЗначений;
	КонецПопытки;
	
КонецФункции

// Создает ETag для валидации кэша на основе контента
// 
// Параметры:
//   Контент - Произвольный - Данные для создания ETag
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   Строка - ETag в виде MD5-хэша
//
Функция СоздатьETag(Контент, ИдентификаторЗапроса = "") Экспорт
	
	Попытка
		ЗаписатьЛог("DEBUG", "Создание ETag", ИдентификаторЗапроса, "", "");
		
		// Сериализуем контент в JSON
		СериализованныйКонтент = mcp_ОбщегоНазначения.СтруктураВJSON(Контент);
		
		// Создаем MD5-хэш
		Хэш = ПолучитьMD5Хэш(СериализованныйКонтент);
		
		// ETag в формате W/"размер-хэш"
		ETag = "W/""" + СтрДлина(СериализованныйКонтент) + "-" + Хэш + """";
		
		ЗаписатьЛог("DEBUG", "ETag создан", ИдентификаторЗапроса, "", "");
		Возврат ETag;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка создания ETag", ИдентификаторЗапроса, "", "");
		ОбработатьОшибку("mcp_Кэширование.СоздатьETag", ИнформацияОбОшибке());
		Возврат "";
	КонецПопытки;
	
КонецФункции

// Проверяет валидность ETag для контента
// 
// Параметры:
//   Контент - Произвольный - Данные для проверки
//   ETag - Строка - ETag для проверки
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   Булево - Истина, если ETag валиден
//
Функция ПроверитьETag(Контент, ETag, ИдентификаторЗапроса = "") Экспорт
	
	Попытка
		ЗаписатьЛог("DEBUG", "Проверка ETag", ИдентификаторЗапроса, "", ETag);
		
		НовыйETag = СоздатьETag(Контент, ИдентификаторЗапроса);
		
		Валиден = (НовыйETag = ETag);
		
		ЗаписатьЛог("DEBUG", "ETag " + ?(Валиден, "валиден", "не валиден"), ИдентификаторЗапроса, "", "");
		Возврат Валиден;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка проверки ETag", ИдентификаторЗапроса, "", "");
		ОбработатьОшибку("mcp_Кэширование.ПроверитьETag", ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Выполняет инвалидацию кэша по событиям
// 
// Параметры:
//   Событие - Строка - Тип события для инвалидации
//   ДанныеСобытия - Структура - Дополнительные данные события
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
Процедура ИнвалидироватьКэшПоСобытию(Событие, ДанныеСобытия = Неопределено, ИдентификаторЗапроса = "") Экспорт
	
	ЗаписатьЛог("INFO", "Инвалидация кэша по событию", ИдентификаторЗапроса, Событие, "");
	
	Попытка
		
		Если Событие = "обновление_конфигурации" Тогда
			// Очищаем кэш метаданных
			ОчиститьКэш("метаданные", ИдентификаторЗапроса);
			
		ИначеЕсли Событие = "обновление_данных" Тогда
			// Очищаем кэш данных по типам
			ТипыОбъектов = Новый Массив;
			Если ДанныеСобытия <> Неопределено И ДанныеСобытия.Свойство("ТипыОбъектов") Тогда
				ТипыОбъектов = ДанныеСобытия.ТипыОбъектов;
			КонецЕсли;
			
			Для Каждого ТипОбъекта Из ТипыОбъектов Цикл
				ОчиститьКэш("данные_" + ТипОбъекта, ИдентификаторЗапроса);
			КонецЦикла;
			
		ИначеЕсли Событие = "регламентная_очистка" Тогда
			// Регламентная очистка истекших записей
			ОчиститьИстекшийКэш(ИдентификаторЗапроса);
			
		Иначе
			ЗаписатьЛог("WARN", "Неизвестное событие инвалидации", ИдентификаторЗапроса, Событие, "");
		КонецЕсли;
		
		ЗаписатьЛог("INFO", "Инвалидация завершена", ИдентификаторЗапроса, Событие, "");
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка инвалидации кэша", ИдентификаторЗапроса, Событие, "");
		ОбработатьОшибку("mcp_Кэширование.ИнвалидироватьКэшПоСобытию", ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Получает статистику использования кэша
// 
// Параметры:
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
// Возвращаемое значение:
//   Структура - Статистика кэша (размер, количество записей, процент попаданий)
//
Функция ПолучитьСтатистикуКэша(ИдентификаторЗапроса = "") Экспорт
	
	ЗаписатьЛог("DEBUG", "Получение статистики кэша", ИдентификаторЗапроса, "", "");
	
	Попытка
		Статистика = Новый Структура;
		Статистика.Вставить("КоличествоЗаписей", ГлобальныйКэш.Количество());
		Статистика.Вставить("ВремяПолучения", ТекущаяДата());
		
		// Подсчет истекших записей
		ИстекшиеЗаписи = 0;
		ВремяТекущее = ТекущаяУниверсальнаяДатаВМиллисекундах();
		
		Для Каждого КлючЗначение Из ГлобальныйКэш Цикл
			Попытка
				СтруктураКэша = mcp_ОбщегоНазначения.JSONВСтруктуру(КлючЗначение.Значение);
				ВремяСоздания = СтруктураКэша.ВремяСоздания;
				ВремяЖизни = СтруктураКэша.ВремяЖизни;
				
				Если (ВремяТекущее - ВремяСоздания) > (ВремяЖизни * 1000) Тогда
					ИстекшиеЗаписи = ИстекшиеЗаписи + 1;
				КонецЕсли;
			Исключение
				// Ошибка парсинга, считаем за истекшую
				ИстекшиеЗаписи = ИстекшиеЗаписи + 1;
			КонецПопытки;
		КонецЦикла;
		
		Статистика.Вставить("ИстекшиеЗаписи", ИстекшиеЗаписи);
		Статистика.Вставить("АктивныеЗаписи", Статистика.КоличествоЗаписей - ИстекшиеЗаписи);
		
		ЗаписатьЛог("DEBUG", "Статистика получена", ИдентификаторЗапроса, "", "");
		Возврат Статистика;
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка получения статистики кэша", ИдентификаторЗапроса, "", "");
		ОбработатьОшибку("mcp_Кэширование.ПолучитьСтатистикуКэша", ИнформацияОбОшибке());
		Возврат Новый Структура;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Инициализация глобального кэша при запуске
Процедура ИнициализироватьКэш() Экспорт
	
	Если ГлобальныйКэш = Неопределено Тогда
		ГлобальныйКэш = Новый Соответствие;
		ЗаписатьЛог("INFO", "Кэш инициализирован", "", "", "");
	КонецЕсли;
	
КонецПроцедуры

// Очищает истекшие записи в кэше
// 
// Параметры:
//   ИдентификаторЗапроса - Строка - Корреляционный идентификатор для логирования
//
Процедура ОчиститьИстекшийКэш(ИдентификаторЗапроса = "") Экспорт
	
	ЗаписатьЛог("INFO", "Очистка истекшего кэша", ИдентификаторЗапроса, "", "");
	
	Попытка
		КоличествоУдаленных = 0;
		ВремяТекущее = ТекущаяУниверсальнаяДатаВМиллисекундах();
		
		КлючиКУдалению = Новый Массив;
		
		Для Каждого КлючЗначение Из ГлобальныйКэш Цикл
			Попытка
				СтруктураКэша = mcp_ОбщегоНазначения.JSONВСтруктуру(КлючЗначение.Значение);
				ВремяСоздания = СтруктураКэша.ВремяСоздания;
				ВремяЖизни = СтруктураКэша.ВремяЖизни;
				
				Если (ВремяТекущее - ВремяСоздания) > (ВремяЖизни * 1000) Тогда
					КлючиКУдалению.Добавить(КлючЗначение.Ключ);
				КонецЕсли;
			Исключение
				// Ошибка парсинга, удаляем запись
				КлючиКУдалению.Добавить(КлючЗначение.Ключ);
			КонецПопытки;
		КонецЦикла;
		
		Для Каждого Ключ Из КлючиКУдалению Цикл
			ГлобальныйКэш.Удалить(Ключ);
			КоличествоУдаленных = КоличествоУдаленных + 1;
		КонецЦикла;
		
		ЗаписатьЛог("INFO", "Истекший кэш очищен", ИдентификаторЗапроса, "", "Удалено: " + КоличествоУдаленных);
		
	Исключение
		ЗаписатьЛог("ERROR", "Ошибка очистки истекшего кэша", ИдентификаторЗапроса, "", "");
		ОбработатьОшибку("mcp_Кэширование.ОчиститьИстекшийКэш", ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Выполняет структурированное логирование операций кэша
// 
// Параметры:
//   Уровень - Строка - Уровень логирования (DEBUG, INFO, WARN, ERROR)
//   Сообщение - Строка - Текст сообщения
//   ИдентификаторЗапроса - Строка - Корреляционный ID
//   Ключ - Строка - Ключ кэша (если применимо)
//   Контекст - Строка - Контекст операции
//
Процедура ЗаписатьЛог(Уровень, Сообщение, ИдентификаторЗапроса, Ключ = "", Контекст = "")
	
	Попытка
		
		ЗаписьЛога = Новый Структура;
		ЗаписьЛога.Вставить("timestamp", ФорматДатыISO8601(ТекущаяУниверсальнаяДатаВМиллисекундах()));
		ЗаписьЛога.Вставить("level", Уровень);
		ЗаписьЛога.Вставить("message", Сообщение);
		ЗаписьЛога.Вставить("module", "mcp_Кэширование");
		ЗаписьЛога.Вставить("request_id", ИдентификаторЗапроса);
		ЗаписьЛога.Вставить("cache_key", Ключ);
		ЗаписьЛога.Вставить("context", Контекст);
		
		// Записываем в журнал регистрации
		ЗаписьJSON = mcp_ОбщегоНазначения.СтруктураВJSON(ЗаписьЛога);
		
		Если Уровень = "ERROR" Тогда
			ЗаписьЖурналаРегистрации("mcp_Кэширование: " + Сообщение, УровеньЛога.Ошибка, , , ЗаписьJSON);
		ИначеЕсли Уровень = "WARN" Тогда
			ЗаписьЖурналаРегистрации("mcp_Кэширование: " + Сообщение, УровеньЛога.Предупреждение, , , ЗаписьJSON);
		Иначе
			ЗаписьЖурналаРегистрации("mcp_Кэширование: " + Сообщение, УровеньЛога.Информация, , , ЗаписьJSON);
		КонецЕсли;
		
	Исключение
		// Логирование ошибки логирования - игнорируем для избежания рекурсии
	КонецПопытки;
	
КонецПроцедуры

// Обрабатывает ошибки в соответствии со стандартами 1С
// 
// Параметры:
//   Контекст - Строка - Контекст возникновения ошибки
//   ИнформацияОбОшибке - ИнформацияОбОшибке - Объект исключения
//
Процедура ОбработатьОшибку(Контекст, ИнформацияОбОшибке)
	
	Попытка
		
		// Формируем подробное представление для администратора
		ПодробноеПредставление = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		
		// Формируем сообщение для пользователя
		СообщениеПользователю = "Произошла ошибка в модуле кэширования. Обратитесь к администратору.";
		
		// Записываем в журнал с полной информацией
		ЗаписьЖурналаРегистрации(
			"Ошибка в " + Контекст + ": " + ПодробноеПредставление,
			УровеньЛога.Ошибка
		);
		
		// Для критических ошибок можно добавить дополнительную обработку
		
	Исключение
		// Последняя попытка логирования без деталей
		ЗаписьЖурналаРегистрации("Критическая ошибка в обработчике ошибок кэширования", УровеньЛога.Ошибка);
	КонецПопытки;
	
КонецПроцедуры

// Форматирует дату в формате ISO 8601
// 
// Параметры:
//   ДатаВМиллисекундах - Число - Дата в миллисекундах от 01.01.0001 00:00:00
//
// Возвращаемое значение:
//   Строка - Дата в формате ISO 8601
//
Функция ФорматДатыISO8601(ДатаВМиллисекундах)
	
	Попытка
		// Преобразуем миллисекунды в дату
		Дата = МестноеВремя(ДатаВМиллисекундах / 1000);
		
		// Форматируем в ISO 8601
		Год = Формат(Дата, "ДФ=yyyy");
		Месяц = Формат(Дата, "ДФ=MM");
		День = Формат(Дата, "ДФ=dd");
		Час = Формат(Дата, "ДФ=HH");
		Минута = Формат(Дата, "ДФ=mm");
		Секунда = Формат(Дата, "ДФ=ss");
		
		Возврат Год + "-" + Месяц + "-" + День + "T" + Час + ":" + Минута + ":" + Секунда + "Z";
		
	Исключение
		Возврат "1970-01-01T00:00:00Z";
	КонецПопытки;
	
КонецФункции

// Получает хэш ключа для использования в качестве ключа в соответствии
// 
// Параметры:
//   Ключ - Строка - Оригинальный ключ
//
// Возвращаемое значение:
//   Строка - Хэшированный ключ
//
Функция ПолучитьХэшКлюча(Ключ)
	
	Попытка
		Хэш = ПолучитьMD5Хэш(Ключ);
		Возврат "cache_" + Хэш;
	Исключение
		Возврат "cache_" + XMLСтрока(Ключ);
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область Инициализация

// Глобальная переменная для хранения кэша
ГлобальныйКэш = Неопределено;

// Инициализируем кэш при загрузке модуля
ИнициализироватьКэш();

#КонецОбласти
