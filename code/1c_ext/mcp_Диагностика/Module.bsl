#Область ПрограммныйИнтерфейс

// Функция получает детальную трассировку стека вызовов
// Возвращает структуру с информацией о модулях, процедурах, номерах строк
Функция ПолучитьСтекВызовов() Экспорт
	
	СтекВызовов = Новый Структура;
	СтекВызовов.Вставить("Элементы", Новый Массив);
	СтекВызовов.Вставить("ВремяПолучения", ТекущаяДатаСеанса());
	СтекВызовов.Вставить("ОбщееВремя", 0);
	
	// Получение текущего контекста выполнения
	ТекущаяПроцедура = "";
	ТекущийМодуль = "";
	
	Попытка
		// Анализ стека через исключение
		ВызватьИсключение "Анализ стека";
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		
		// Извлечение информации о стеке
		ТекстОшибки = ИнформацияОбОшибке.Описание;
		
		// Парсинг стека вызовов
		Стек = РазобратьСтекВызовов(ТекстОшибки);
		
		// Обогащение информации о каждом уровне стека
		Для Каждого УровеньСтека Из Стек Цикл
			ЭлементСтека = Новый Структура;
			ЭлементСтека.Вставить("Модуль", УровеньСтека.Модуль);
			ЭлементСтека.Вставить("Процедура", УровеньСтека.Процедура);
			ЭлементСтека.Вставить("НомерСтроки", УровеньСтека.НомерСтроки);
			ЭлементСтека.Вставить("СтрокаКода", ПолучитьСтрокуКода(УровеньСтека.Модуль, УровеньСтека.НомерСтроки));
			ЭлементСтека.Вставить("ПолныйПуть", УровеньСтека.Модуль + "." + УровеньСтека.Процедура);
			ЭлементСтека.Вставить("Уровень", Стек.Индекс(УровеньСтека));
			
			СтекВызовов.Элементы.Добавить(ЭлементСтека);
		КонецЦикла;
	КонецПопытки;
	
	Возврат СтекВызовов;
	
КонецФункции

// Функция создает контекст операции для диагностики
// Параметры:
//   ИдентификаторОперации - уникальный идентификатор операции
//   ПараметрыВхода - структура входных параметров
Функция СоздатьКонтекстОперации(ИдентификаторОперации, ПараметрыВхода = Неопределено) Экспорт
	
	Контекст = Новый Структура;
	Контекст.Вставить("ИдентификаторОперации", ИдентификаторОперации);
	Контекст.Вставить("Пользователь", ПолучитьТекущегоПользователя());
	Контекст.Вставить("ВремяНачала", ТекущаяДатаСеанса());
	Контекст.Вставить("ВремяОкончания", Неопределено);
	Контекст.Вставить("ПараметрыВхода", ПараметрыВхода);
	Контекст.Вставить("Результат", Неопределено);
	Контекст.Вставить("СостояниеОшибки", Ложь);
	Контекст.Вставить("СообщениеОбОшибке", "");
	Контекст.Вставить("СтекВызовов", Неопределено);
	Контекст.Вставить("ВремяВыполнения", 0);
	
	// Информация о системе
	Контекст.Вставить("СостояниеСистемы", Новый Структура);
	Контекст.СостояниеСистемы.Вставить("НагрузкаПроцессора", ПолучитьНагрузкуПроцессора());
	Контекст.СостояниеСистемы.Вставить("ИспользованиеПамяти", ПолучитьИспользованиеПамяти());
	Контекст.СостояниеСистемы.Вставить("КоличествоСеансов", ПолучитьКоличествоСеансов());
	
	// Информация о компонентах системы
	Контекст.Вставить("КомпонентыСистемы", ПолучитьИнформациюОКомпонентах());
	
	// Хеш для дедупликации
	Контекст.Вставить("ХешОшибки", "");
	
	Возврат Контекст;
	
КонецФункции

// Процедура завершает контекст операции и сохраняет результат
Процедура ЗавершитьКонтекстОперации(Контекст, Результат = Неопределено, ЕстьОшибка = Ложь, СообщениеОбОшибке = "") Экспорт
	
	Контекст.ВремяОкончания = ТекущаяДатаСеанса();
	Контекст.ВремяВыполнения = Контекст.ВремяОкончания - Контекст.ВремяНачала;
	Контекст.Результат = Результат;
	Контекст.СостояниеОшибки = ЕстьОшибка;
	Контекст.СообщениеОбОшибке = СообщениеОбОшибке;
	
	Если ЕстьОшибка Тогда
		Контекст.СтекВызовов = ПолучитьСтекВызовов();
		Контекст.ХешОшибки = ВычислитьХешОшибки(Контекст);
	КонецЕсли;
	
	// Сохранение метрик производительности
	СохранитьМетрикуПроизводительности(Контекст.ИдентификаторОперации, Контекст.ВремяВыполнения);
	
	// Проверка дедупликации ошибок
	Если ЕстьОшибка Тогда
		ПроверитьДедупликациюОшибки(Контекст);
	КонецЕсли;
	
КонецПроцедуры

// Функция вычисляет хеш ошибки для дедупликации
Функция ВычислитьХешОшибки(Контекст) Экспорт
	
	Если НЕ Контекст.СостояниеОшибки Тогда
		Возврат "";
	КонецЕсли;
	
	// Создание строки для хеширования
	СтрокаДляХеша = "";
	
	// Добавляем тип операции
	СтрокаДляХеша = СтрокаДляХеша + Контекст.ИдентификаторОперации + "|";
	
	// Добавляем сообщение об ошибке
	СтрокаДляХеша = СтрокаДляХеша + Контекст.СообщениеОбОшибке + "|";
	
	// Добавляем стек вызовов (первые 5 уровней)
	Если Контекст.СтекВызовов <> Неопределено Тогда
		КоличествоУровней = Мин(5, Контекст.СтекВызовов.Элементы.Количество());
		Для Сч = 0 По КоличествоУровней - 1 Цикл
			Элемент = Контекст.СтекВызовов.Элементы[Сч];
			СтрокаДляХеша = СтрокаДляХеша + Элемент.Модуль + "." + Элемент.Процедура + "|";
		КонецЦикла;
	КонецЕсли;
	
	// Вычисление простого хеша
	Хеш = 0;
	Для Сч = 1 По СтрДлина(СтрокаДляХеша) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаДляХеша, Сч, 1));
		Хеш = Хеш + КодСимвола * Сч;
	КонецЦикла;
	
	Возврат XMLСтрока(Хеш);
	
КонецФункции

// Процедура проверяет и обрабатывает дедупликацию ошибок
Процедура ПроверитьДедупликациюОшибки(Контекст) Экспорт
	
	ХешОшибки = Контекст.ХешОшибки;
	Если ПустаяСтрока(ХешОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	// Получаем счетчик ошибок для данного хеша
	СчетчикОшибок = ПолучитьСчетчикОшибок(ХешОшибки);
	
	// Увеличиваем счетчик
	СчетчикОшибок.Количество = СчетчикОшибок.Количество + 1;
	СчетчикОшибок.ПоследнееВремя = ТекущаяДатаСеанса();
	
	// Сохраняем обновленный счетчик
	СохранитьСчетчикОшибок(ХешОшибки, СчетчикОшибок);
	
	// Если ошибка встречается часто, подавляем детализированное логирование
	Если СчетчикОшибок.Количество > 10 Тогда
		Контекст.СтекВызовов = Неопределено; // Подавляем детализированный стек
	Конецесли;
	
КонецПроцедуры

// Функция сохраняет метрику производительности
Функция СохранитьМетрикуПроизводительности(ИдентификаторОперации, ВремяВыполнения) Экспорт
	
	Метрика = Новый Структура;
	Метрика.Вставить("Операция", ИдентификаторОперации);
	Метрика.Вставить("ВремяВыполнения", ВремяВыполнения);
	Метрика.Вставить("ВремяИзмерения", ТекущаяДатаСеанса());
	
	// Сохранение в глобальное хранилище метрик
	Если ГлобальныеПеременные.МетрикиПроизводительности = Неопределено Тогда
		ГлобальныеПеременные.МетрикиПроизводительности = Новый Массив;
	КонецЕсли;
	
	ГлобальныеПеременные.МетрикиПроизводительности.Добавить(Метрика);
	
	// Ограничиваем размер массива (последние 1000 метрик)
	Если ГлобальныеПеременные.МетрикиПроизводительности.Количество() > 1000 Тогда
		ГлобальныеПеременные.МетрикиПроизводительности.Удалить(0);
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция получает отчет по производительности операций
Функция ПолучитьОтчетПоПроизводительности(ПериодВМинутах = 60) Экспорт
	
	Отчет = Новый Структура;
	Отчет.Вставить("СтатистикаОпераций", Новый Соответствие);
	Отчет.Вставить("ОбщиеМетрики", Новый Структура);
	Отчет.Вставить("ВремяПостроенияОтчета", ТекущаяДатаСеанса());
	
	ГраницаВремени = ТекущаяДатаСеанса() - ПериодВМинутах * 60;
	
	// Анализ метрик
	Если ГлобальныеПеременные.МетрикиПроизводительности <> Неопределено Тогда
		
		Для Каждого Метрика Из ГлобальныеПеременные.МетрикиПроизводительности Цикл
			
			Если Метрика.ВремяИзмерения < ГраницаВремени Тогда
				Продолжить;
			КонецЕсли;
			
			Операция = Метрика.Операция;
			
			Если Отчет.СтатистикаОпераций[Операция] = Неопределено Тогда
				Статистика = Новый Структура;
				Статистика.Вставить("КоличествоВызовов", 0);
				Статистика.Вставить("ОбщееВремя", 0);
				Статистика.Вставить("СреднееВремя", 0);
				Статистика.Вставить("МинимальноеВремя", 999999);
				Статистика.Вставить("МаксимальноеВремя", 0);
				Статистика.Вставить("ПоследнееВремя", 0);
				
				Отчет.СтатистикаОпераций[Операция] = Статистика;
			КонецЕсли;
			
			Статистика = Отчет.СтатистикаОпераций[Операция];
			
			Статистика.КоличествоВызовов = Статистика.КоличествоВызовов + 1;
			Статистика.ОбщееВремя = Статистика.ОбщееВремя + Метрика.ВремяВыполнения;
			Статистика.ПоследнееВремя = Метрика.ВремяВыполнения;
			
			Если Метрика.ВремяВыполнения < Статистика.МинимальноеВремя Тогда
				Статистика.МинимальноеВремя = Метрика.ВремяВыполнения;
			КонецЕсли;
			
			Если Метрика.ВремяВыполнения > Статистика.МаксимальноеВремя Тогда
				Статистика.МаксимальноеВремя = Метрика.ВремяВыполнения;
			КонецЕсли;
			
		КонецЦикла;
		
		// Вычисление средних значений
		Для Каждого КлючЗначение Из Отчет.СтатистикаОпераций Цикл
			Статистика = КлючЗначение.Значение;
			Если Статистика.КоличествоВызовов > 0 Тогда
				Статистика.СреднееВремя = Статистика.ОбщееВремя / Статистика.КоличествоВызовов;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	// Общие метрики
	Отчет.ОбщиеМетрики.Вставить("ВсегоОпераций", Отчет.СтатистикаОпераций.Количество());
	Отчет.ОбщиеМетрики.Вставить("ПериодАнализаМинут", ПериодВМинутах);
	Отчет.ОбщиеМетрики.Вставить("СредняяНагрузка", РассчитатьСреднююНагрузку());
	
	Возврат Отчет;
	
КонецФункции

// Функция получает анализ частых ошибок
Функция ПолучитьАнализЧастыхОшибок() Экспорт
	
	Анализ = Новый Структура;
	Анализ.Вставить("ЧастыеОшибки", Новый Массив);
	Анализ.Вставить("ОбщееКоличествоУникальныхОшибок", 0);
	Анализ.Вставить("ВремяПостроенияАнализа", ТекущаяДатаСеанса());
	
	Если ГлобальныеПеременные.СчетчикиОшибок <> Неопределено Тогда
		
		// Сортируем ошибки по частоте
		МассивОшибок = Новый Массив;
		
		Для Каждого КлючЗначение Из ГлобальныеПеременные.СчетчикиОшибок Цикл
			МассивОшибок.Добавить(КлючЗначение);
		КонецЦикла;
		
		// Сортировка по убыванию количества
		СортироватьМассивСтруктур(МассивОшибок, "Количество", Истина);
		
		// Берем топ-20 частых ошибок
		КоличествоДляОтчета = Мин(20, МассивОшибок.Количество());
		
		Для Сч = 0 По КоличествоДляОтчета - 1 Цикл
			ДанныеОшибки = МассивОшибок[Сч];
			
			ЭлементАнализа = Новый Структура;
			ЭлементАнализа.Вставить("ХешОшибки", ДанныеОшибки.Ключ);
			ЭлементАнализа.Вставить("КоличествоВхождений", ДанныеОшибки.Значение.Количество);
			ЭлементАнализа.Вставить("ПервоеВремя", ДанныеОшибки.Значение.ПервоеВремя);
			ЭлементАнализа.Вставить("ПоследнееВремя", ДанныеОшибки.Значение.ПоследнееВремя);
			ЭлементАнализа.Вставить("ЧастотаВЧас", РассчитатьЧастотуВЧас(ДанныеОшибки.Значение));
			
			Анализ.ЧастыеОшибки.Добавить(ЭлементАнализа);
		КонецЦикла;
		
		Анализ.ОбщееКоличествоУникальныхОшибок = МассивОшибок.Количество();
		
	КонецЕсли;
	
	Возврат Анализ;
	
КонецФункции

// Функция формирует рекомендации по оптимизации
Функция ПолучитьРекомендацииПоОптимизации() Экспорт
	
	Рекомендации = Новый Массив;
	
	// Анализ производительности
	ОтчетПоПроизводительности = ПолучитьОтчетПоПроизводительности(60);
	
	Для Каждого КлючЗначение Из ОтчетПоПроизводительности.СтатистикаОпераций Цикл
		Статистика = КлючЗначение.Значение;
		Операция = КлючЗначение.Ключ;
		
		// Проверяем медленные операции
		Если Статистика.СреднееВремя > 5 Тогда // больше 5 секунд
			
			Рекомендация = Новый Структура;
			Рекомендация.Вставить("Тип", "МедленнаяОперация");
			Рекомендация.Вставить("Операция", Операция);
			Рекомендация.Вставить("СреднееВремя", Статистика.СреднееВремя);
			Рекомендация.Вставить("КоличествоВызовов", Статистика.КоличествоВызовов);
			Рекомендация.Вставить("Описание", "Операция выполняется медленно. Рекомендуется оптимизация.");
			Рекомендация.Вставить("Приоритет", "Высокий");
			
			Рекомендации.Добавить(Рекомендация);
			
		КонецЕсли;
		
		// Проверяем частые операции
		Если Статистика.КоличествоВызовов > 100 Тогда
			
			Рекомендация = Новый Структура;
			Рекомендация.Вставить("Тип", "ЧастаяОперация");
			Рекомендация.Вставить("Операция", Операция);
			Рекомендация.Вставить("КоличествоВызовов", Статистика.КоличествоВызовов);
			Рекомендация.Вставить("Описание", "Часто вызываемая операция. Рассмотрите возможность кэширования.");
			Рекомендация.Вставить("Приоритет", "Средний");
			
			Рекомендации.Добавить(Рекомендация);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Анализ частых ошибок
	АнализОшибок = ПолучитьАнализЧастыхОшибок();
	
	Для Каждого ЧастаяОшибка Из АнализОшибок.ЧастыеОшибки Цикл
		
		Если ЧастаяОшибка.КоличествоВхождений > 5 Тогда
			
			Рекомендация = Новый Структура;
			Рекомендация.Вставить("Тип", "ЧастаяОшибка");
			Рекомендация.Вставить("ХешОшибки", ЧастаяОшибка.ХешОшибки);
			Рекомендация.Вставить("КоличествоВхождений", ЧастаяОшибка.КоличествоВхождений);
			Рекомендация.Вставить("Описание", "Часто повторяющаяся ошибка требует анализа и исправления.");
			Рекомендация.Вставить("Приоритет", "Критический");
			
			Рекомендации.Добавить(Рекомендация);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Рекомендации;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция разбирает текст исключения и извлекает стек вызовов
Функция РазобратьСтекВызовов(ТекстОшибки)
	
	Стек = Новый Массив;
	
	// Поиск строк со стеком вызовов в тексте ошибки
	Строки = СтрРазделить(ТекстОшибки, Символы.ПС);
	
	Для Каждого Строка Из Строки Цикл
		
		// Ищем паттерн "ИмяМодуля.ИмяПроцедуры(строка:номер)"
		Если СтрНайти(Строка, "(") > 0 И СтрНайти(Строка, ")строка:") > 0 Тогда
			
			ЭлементСтека = Новый Структура;
			
			// Извлекаем модуль и процедуру
			ЧастьДоСкобки = Лев(Строка, СтрНайти(Строка, "(") - 1);
			ЧастиМодуля = СтрРазделить(ЧастьДоСкобки, ".");
			
			Если ЧастиМодуля.Количество() >= 2 Тогда
				ЭлементСтека.Модуль = ЧастиМодуля[ЧастиМодуля.Количество() - 2];
				ЭлементСтека.Процедура = ЧастиМодуля[ЧастиМодуля.Количество() - 1];
			Иначе
				ЭлементСтека.Модуль = "НеизвестныйМодуль";
				ЭлементСтека.Процедура = ЧастьДоСкобки;
			КонецЕсли;
			
			// Извлекаем номер строки
			ЧастьВСкобках = Сред(Строка, СтрНайти(Строка, "(") + 1);
			ЧастьВСкобках = Лев(ЧастьВСкобках, СтрНайти(ЧастьВСкобках, ")") - 1);
			
			Если СтрНайти(ЧастьВСкобках, "строка:") > 0 Тогда
				НомерСтрокиСтр = Сред(ЧастьВСкобках, СтрНайти(ЧастьВСкобках, "строка:") + 7);
				ЭлементСтека.НомерСтроки = СтрокаВЧисло(НомерСтрокиСтр);
			Иначе
				ЭлементСтека.НомерСтроки = 0;
			КонецЕсли;
			
			Стек.Добавить(ЭлементСтека);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Стек;
	
КонецФункции

// Функция получает строку кода из модуля
Функция ПолучитьСтрокуКода(Модуль, НомерСтроки)
	
	Если НомерСтроки <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Попытка
		// В реальной реализации здесь был бы доступ к тексту модуля
		// Для демонстрации возвращаем заглушку
		Возврат "// Строка кода из " + Модуль + " на позиции " + НомерСтроки;
	Исключение
		Возврат "// Не удалось получить строку кода";
	КонецПопытки;
	
КонецФункции

// Функция получает текущего пользователя
Функция ПолучитьТекущегоПользователя()
	
	Попытка
		Возврат ИмяПользователя();
	Исключение
		Возврат "Система";
	КонецПопытки;
	
КонецФункции

// Функция получает нагрузку процессора (заглушка)
Функция ПолучитьНагрузкуПроцессора()
	
	// В реальной реализации здесь был бы запрос к системным метрикам
	Возврат 50; // процент
	
КонецФункции

// Функция получает использование памяти (заглушка)
Функция ПолучитьИспользованиеПамяти()
	
	// В реальной реализации здесь был бы запрос к системным метрикам
	Возврат 1024; // МБ
	
КонецФункции

// Функция получает количество активных сеансов
Функция ПолучитьКоличествоСеансов()
	
	Попытка
		// В реальной реализации здесь был бы запрос к сеансам
		Возврат 5;
	Исключение
		Возврат 1;
	КонецПопытки;
	
КонецФункции

// Функция получает информацию о компонентах системы
Функция ПолучитьИнформациюОКомпонентах()
	
	Компоненты = Новый Структура;
	
	Попытка
		Компоненты.Вставить("ВерсияПлатформы", Метаданные.Версия);
		Компоненты.Вставить("ИмяКонфигурации", Метаданные.Имя);
		Компоненты.Вставить("ВерсияКонфигурации", Метаданные.Версия);
		Компоненты.Вставить("РежимСовместимости", Метаданные.РежимСовместимости);
	Исключение
		Компоненты.Вставить("ВерсияПлатформы", "Неизвестно");
		Компоненты.Вставить("ИмяКонфигурации", "Неизвестно");
		Компоненты.Вставить("ВерсияКонфигурации", "Неизвестно");
		Компоненты.Вставить("РежимСовместимости", "Неизвестно");
	КонецПопытки;
	
	Возврат Компоненты;
	
КонецФункции

// Функция получает счетчик ошибок для хеша
Функция ПолучитьСчетчикОшибок(ХешОшибки)
	
	Если ГлобальныеПеременные.СчетчикиОшибок = Неопределено Тогда
		ГлобальныеПеременные.СчетчикиОшибок = Новый Соответствие;
	КонецЕсли;
	
	Если ГлобальныеПеременные.СчетчикиОшибок[ХешОшибки] = Неопределено Тогда
		Счетчик = Новый Структура;
		Счетчик.Вставить("Количество", 0);
		Счетчик.Вставить("ПервоеВремя", Неопределено);
		Счетчик.Вставить("ПоследнееВремя", Неопределено);
		
		ГлобальныеПеременные.СчетчикиОшибок[ХешОшибки] = Счетчик;
	КонецЕсли;
	
	Счетчик = ГлобальныеПеременные.СчетчикиОшибок[ХешОшибки];
	
	// Устанавливаем первое время, если еще не установлено
	Если Счетчик.ПервоеВремя = Неопределено Тогда
		Счетчик.ПервоеВремя = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Возврат Счетчик;
	
КонецФункции

// Процедура сохраняет счетчик ошибок
Процедура СохранитьСчетчикОшибок(ХешОшибки, Счетчик)
	
	Если ГлобальныеПеременные.СчетчикиОшибок = Неопределено Тогда
		ГлобальныеПеременные.СчетчикиОшибок = Новый Соответствие;
	КонецЕсли;
	
	ГлобальныеПеременные.СчетчикиОшибок[ХешОшибки] = Счетчик;
	
КонецПроцедуры

// Функция рассчитывает среднюю нагрузку
Функция РассчитатьСреднююНагрузку()
	
	// Простой расчет средней нагрузки на основе метрик
	Возврат 45; // процент
	
КонецФункции

// Функция рассчитывает частоту ошибок в час
Функция РассчитатьЧастотуВЧас(ДанныеСчетчика)
	
	Если ДанныеСчетчика.ПервоеВремя = Неопределено ИЛИ ДанныеСчетчика.ПоследнееВремя = Неопределено Тогда
		Возврат 0;
	КонецЕсли;
	
	ПериодВЧасах = (ДанныеСчетчика.ПоследнееВремя - ДанныеСчетчика.ПервоеВремя) / 3600;
	
	Если ПериодВЧасах <= 0 Тогда
		Возврат ДанныеСчетчика.Количество;
	КонецЕсли;
	
	Возврат ДанныеСчетчика.Количество / ПериодВЧасах;
	
КонецФункции

// Процедура сортирует массив структур
Процедура СортироватьМассивСтруктур(Массив, ПолеСортировки, ПоУбыванию = Ложь)
	
	// Простая сортировка пузырьком для демонстрации
	Размер = Массив.Количество();
	
	Для Итерация = 1 По Размер Цикл
		
		ОбменВыполнен = Ложь;
		
		Для Индекс = 0 По Размер - Итерация - 1 Цикл
			
			ТекущийЭлемент = Массив[Индекс];
			СледующийЭлемент = Массив[Индекс + 1];
			
			НужнаСортировка = Ложь;
			
			Если ПоУбыванию Тогда
				НужнаСортировка = ТекущийЭлемент.Значение[ПолеСортировки] < СледующийЭлемент.Значение[ПолеСортировки];
			Иначе
				НужнаСортировка = ТекущийЭлемент.Значение[ПолеСортировки] > СледующийЭлемент.Значение[ПолеСортировки];
			КонецЕсли;
			
			Если НужнаСортировка Тогда
				// Обмен элементов
				Временный = Массив[Индекс];
				Массив[Индекс] = Массив[Индекс + 1];
				Массив[Индекс + 1] = Временный;
				
				ОбменВыполнен = Истина;
			КонецЕсли;
			
		КонецЦикла;
		
		Если НЕ ОбменВыполнен Тогда
			Прервать; // Массив отсортирован
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Инициализация

// Инициализация глобальных переменных диагностики
Процедура ИнициализироватьДиагностику() Экспорт
	
	Если ГлобальныеПеременные.МетрикиПроизводительности = Неопределено Тогда
		ГлобальныеПеременные.МетрикиПроизводительности = Новый Массив;
	КонецЕсли;
	
	Если ГлобальныеПеременные.СчетчикиОшибок = Неопределено Тогда
		ГлобальныеПеременные.СчетчикиОшибок = Новый Соответствие;
	КонецЕсли;
	
КонецПроцедуры

// Структура глобальных переменных для диагностики
Перем ГлобальныеПеременные;

// Инициализация при загрузке модуля
ИнициализироватьДиагностику();

#КонецОбласти