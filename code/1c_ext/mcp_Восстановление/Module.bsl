// Модуль механизмов восстановления и retry логики для 1С
// Предоставляет функциональность для обработки ошибок и автоматического восстановления
// Версия: 1.0
// Автор: MCP Recovery System

#Область СлужебныйПрограммныйИнтерфейс

// Выполняет код с автоматическими retry попытками и экспоненциальной задержкой
// 
// Параметры:
//   ВыполняемыйКод - Строка - Выполняемый код или имя функции
//   МаксимумПопыток - Число - Максимальное количество попыток (по умолчанию 3)
//   НачальнаяЗадержкаМс - Число - Начальная задержка в миллисекундах (по умолчанию 100)
//   Множитель - Число - Множитель для экспоненциального роста (по умолчанию 2)
//   Контекст - Строка - Контекст выполнения для логирования
//
// Возвращаемое значение:
//   Структура - Результат выполнения с полями Успех, Результат, ОписаниеОшибки, КоличествоПопыток
//
Функция ВыполнитьСРетрай(ВыполняемыйКод, МаксимумПопыток = 3, НачальнаяЗадержкаМс = 100, Множитель = 2, Контекст = "") Экспорт
	
	Результат = Новый Структура("Успех, Результат, ОписаниеОшибки, КоличествоПопыток, ВремяВыполнения", 
		Ложь, Неопределено, "", 0, 0);
	
	НачалоВыполнения = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	// Получаем функцию обработчик
	ФункцияОбработчик = ПолучитьФункциюОбработчик(ВыполняемыйКод);
	
	Для НомерПопытки = 1 По МаксимумПопыток Цикл
		
		Результат.КоличествоПопыток = НомерПопытки;
		
		Попытка
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
				СтрШаблон("Retry попытка %1/%2 для: %3", НомерПопытки, МаксимумПопыток, Контекст));
			
			// Выполняем код
			Если ТипЗнч(ФункцияОбработчик) = Тип("Строка") Тогда
				// Выполняем код как строку
				РезультатВыполнения = Выполнить(ФункцияОбработчик);
			ИначеЕсли ТипЗнч(ФункцияОбработчик) = Тип("Структура") И ФункцияОбработчик.Свойство("Процедура") Тогда
				// Выполняем процедуру/функцию
				Если ФункцияОбработчик.Параметры <> Неопределено Тогда
					ВызватьФункцию(ФункцияОбработчик.Процедура, ФункцияОбработчик.Параметры, РезультатВыполнения);
				Иначе
					РезультатВыполнения = ВызватьФункцию(ФункцияОбработчик.Процедура);
				КонецЕсли;
			Иначе
				РезультатВыполнения = ВызватьФункцию(ФункцияОбработчик);
			КонецЕсли;
			
			Результат.Успех = Истина;
			Результат.Результат = РезультатВыполнения;
			Результат.ВремяВыполнения = ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоВыполнения;
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
				СтрШаблон("Retry успешен с попытки %1. Время выполнения: %2 мс", 
				НомерПопытки, Результат.ВремяВыполнения));
			
			Возврат Результат;
			
		Исключение
			
			ОписаниеОшибки = ОписаниеОшибкиИнформация();
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Предупреждение, 
				СтрШаблон("Retry попытка %1/%2 завершилась с ошибкой: %3", 
				НомерПопытки, МаксимумПопыток, ОписаниеОшибки.Описание));
			
			Результат.ОписаниеОшибки = ОписаниеОшибки.Описание;
			
			// Если это последняя попытка, прерываем
			Если НомерПопытки >= МаксимумПопыток Тогда
				Результат.ВремяВыполнения = ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоВыполнения;
				Возврат Результат;
			КонецЕсли;
			
			// Вычисляем задержку с экспоненциальным ростом и джиттером
			Задержка = НачальнаяЗадержкаМс * Pow(Множитель, НомерПопытки - 1);
			Задержка = ДобавитьДжиттер(Задержка);
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
				СтрШаблон("Ожидание %1 мс перед следующей попыткой", Задержка));
			
			// Пауза перед следующей попыткой
			Пауза(Задержка);
			
		КонецПопытки;
		
	КонецЦикла;
	
	Результат.ВремяВыполнения = ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоВыполнения;
	Возврат Результат;
	
КонецФункции

// Выполняет код в транзакции с автоматическим откатом при ошибках
//
// Параметры:
//   ВыполняемыйКод - Строка - Выполняемый код или имя функции
//   Контекст - Строка - Контекст выполнения для логирования
//   УровеньИзоляции - УровеньИзоляцииТранзакции - Уровень изоляции транзакции
//
// Возвращаемое значение:
//   Структура - Результат выполнения с полями Успех, Результат, ОписаниеОшибки
//
Функция ВыполнитьВТранзакцииСОткатом(ВыполняемыйКод, Контекст = "", УровеньИзоляции = Неопределено) Экспорт
	
	Результат = Новый Структура("Успех, Результат, ОписаниеОшибки", 
		Ложь, Неопределено, "");
	
	// Сохраняем состояние перед транзакцией
	СостояниеСистемы = СохранитьСостояниеСистемы();
	
	Попытка
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
			СтрШаблон("Начало транзакции для: %1", Контекст));
		
		// Начинаем транзакцию
		НачатьТранзакцию();
		
		// Получаем функцию обработчик
		ФункцияОбработчик = ПолучитьФункциюОбработчик(ВыполняемыйКод);
		
		// Выполняем код
		Если ТипЗнч(ФункцияОбработчик) = Тип("Строка") Тогда
			РезультатВыполнения = Выполнить(ФункцияОбработчик);
		Иначе
			РезультатВыполнения = ВызватьФункцию(ФункцияОбработчик);
		КонецЕсли;
		
		// Зафиксировать транзакцию
		ЗафиксироватьТранзакцию();
		
		Результат.Успех = Истина;
		Результат.Результат = РезультатВыполнения;
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
			СтрШаблон("Транзакция успешно завершена для: %1", Контекст));
		
	Исключение
		
		// Откатываем транзакцию
		Попытка
			ОтменитьТранзакцию();
		Исключение
			// Игнорируем ошибки при откате
		КонецПопытки;
		
		ОписаниеОшибки = ОписаниеОшибкиИнформация();
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Ошибка, 
			СтрШаблон("Откат транзакции для %1. Причина: %2", 
			Контекст, ОписаниеОшибки.Описание));
		
		Результат.ОписаниеОшибки = ОписаниеОшибки.Описание;
		
		// Восстанавливаем состояние системы
		ВосстановитьСостояниеСистемы(СостояниеСистемы);
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Circuit Breaker - паттерн для защиты от каскадных сбоев
// 
// Параметры:
//   ИмяСервиса - Строка - Имя сервиса для которого создается breaker
//   ЛимитОшибок - Число - Лимит ошибок для перехода в состояние OPEN (по умолчанию 5)
//   ПериодСекунд - Число - Период времени для подсчета ошибок (по умолчанию 60)
//   TimeoutСекунд - Число - Время ожидания в состоянии OPEN (по умолчанию 30)
//
// Возвращаемое значение:
//   Структура - Результат выполнения с полями Успех, Результат, ОписаниеОшибки, Состояние
//
Функция ВыполнитьСCircuitBreaker(ИмяСервиса, ВыполняемыйКод, ЛимитОшибок = 5, ПериодСекунд = 60, TimeoutСекунд = 30) Экспорт
	
	Результат = Новый Структура("Успех, Результат, ОписаниеОшибки, Состояние", 
		Ложь, Неопределено, "", "");
	
	// Получаем или создаем состояние breaker для сервиса
	BreakerСостояние = ПолучитьСостояниеBreaker(ИмяСервиса);
	
	ПроверитьИОбновитьСостояниеBreaker(BreakerСостояние, ПериодСекунд, TimeoutСекунд);
	
	Результат.Состояние = BreakerСостояние.Состояние;
	
	// Если breaker в состоянии OPEN, сразу возвращаем ошибку
	Если BreakerСостояние.Состояние = "OPEN" Тогда
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Предупреждение, 
			СтрШаблон("Circuit Breaker %1 в состоянии OPEN, запрос отклонен", ИмяСервиса));
		
		Результат.ОписаниеОшибки = СтрШаблон("Circuit Breaker %1 в состоянии OPEN", ИмяСервиса);
		Возврат Результат;
		
	КонецЕсли;
	
	Попытка
		
		// Получаем функцию обработчик
		ФункцияОбработчик = ПолучитьФункциюОбработчик(ВыполняемыйКод);
		
		// Выполняем код
		Если ТипЗнч(ФункцияОбработчик) = Тип("Строка") Тогда
			РезультатВыполнения = Выполнить(ФункцияОбработчик);
		Иначе
			РезультатВыполнения = ВызватьФункцию(ФункцияОбработчик);
		КонецЕсли;
		
		// Успешное выполнение
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
			СтрШаблон("Circuit Breaker %1: успешное выполнение", ИмяСервиса));
		
		ОбработатьУспехBreaker(BreakerСостояние, ЛимитОшибок);
		
		Результат.Успех = Истина;
		Результат.Результат = РезультатВыполнения;
		
	Исключение
		
		ОписаниеОшибки = ОписаниеОшибкиИнформация();
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Ошибка, 
			СтрШаблон("Circuit Breaker %1: ошибка выполнения - %2", ИмяСервиса, ОписаниеОшибки.Описание));
		
		Результат.ОписаниеОшибки = ОписаниеОшибки.Описание;
		
		// Обрабатываем ошибку в breaker
		ОбработатьОшибкуBreaker(BreakerСостояние, ЛимитОшибок, ОписаниеОшибки.Описание);
		
	КонецПопытки;
	
	// Сохраняем обновленное состояние
	СохранитьСостояниеBreaker(ИмяСервиса, BreakerСостояние);
	
	Результат.Состояние = BreakerСостояние.Состояние;
	Возврат Результат;
	
КонецФункции

// Graceful degradation - постепенное понижение качества обслуживания
//
// Параметры:
//   Операция - Строка - Тип операции для деградации
//   ПараметрыОперации - Структура - Параметры операции
//   Приоритет - Число - Приоритет операции (1-высокий, 5-низкий)
//
// Возвращаемое значение:
//   Структура - Результат с полями Успех, Результат, УровеньДеградации, Сообщение
//
Функция ВыполнитьСGracefulDegradation(Операция, ПараметрыОперации = Неопределено, Приоритет = 3) Экспорт
	
	Результат = Новый Структура("Успех, Результат, УровеньДеградации, Сообщение", 
		Ложь, Неопределено, 0, "");
	
	// Определяем критичность операции
	Критичность = ОпределитьКритичностьОперации(Операция);
	
	// Получаем fallback стратегию для операции
	FallbackСтратегия = ПолучитьFallbackСтратегию(Операция);
	
	УровеньДеградации = 0;
	
	Попытка
		
		// Пытаемся выполнить операцию с увеличением timeout
		Для Уровень = 0 По 3 Цикл
			
			УровеньДеградации = Уровень;
			Timeout = ПолучитьTimeoutДляУровня(Уровень);
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
				СтрШаблон("Graceful degradation: попытка уровня %1 для операции %2", Уровень, Операция));
			
			РезультатПопытки = ВыполнитьОперациюСTimeout(Операция, ПараметрыОперации, Timeout);
			
			Если РезультатПопытки.Успех Тогда
				Результат.Успех = Истина;
				Результат.Результат = РезультатПопытки.Результат;
				Результат.УровеньДеградации = Уровень;
				Результат.Сообщение = СтрШаблон("Операция выполнена на уровне деградации %1", Уровень);
				
				// Обновляем кэш успешных результатов
				ОбновитьКэшРезультатов(Операция, РезультатПопытки.Результат);
				Возврат Результат;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если все попытки неудачны, используем fallback
		РезультатFallback = ВыполнитьFallback(FallbackСтратегия, Операция, ПараметрыОперации);
		
		Результат.Успех = РезультатFallback.Успех;
		Результат.Результат = РезультатFallback.Результат;
		Результат.УровеньДеградации = 4;
		Результат.Сообщение = "Использован fallback результат";
		
		// Уведомляем об использовании fallback
		УведомитьОбИспользованииFallback(Операция, РезультатFallback);
		
	Исключение
		
		ОписаниеОшибки = ОписаниеОшибкиИнформация();
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Ошибка, 
			СтрШаблон("Graceful degradation для операции %1 завершилось ошибкой: %2", 
			Операция, ОписаниеОшибки.Описание));
		
		// Используем последний кэшированный результат как fallback
		КэшированныйРезультат = ПолучитьКэшированныйРезультат(Операция);
		
		Если КэшированныйРезультат <> Неопределено Тогда
			Результат.Успех = Истина;
			Результат.Результат = КэшированныйРезультат;
			Результат.УровеньДеградации = 5;
			Результат.Сообщение = "Использован кэшированный результат";
		Иначе
			Результат.Сообщение = СтрШаблон("Ошибка graceful degradation: %1", ОписаниеОшибки.Описание);
		КонецЕсли;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Добавляет джиттер к задержке для избежания синхронизации запросов
Функция ДобавитьДжиттер(Задержка)
	
	// Джиттер от -25% до +25% от базовой задержки
	Генератор = Новый ГенераторСлучайныхЧисел;
	Коэффициент = 0.75 + Генератор.СлучайноеЧисло(0, 50) / 100;
	
	Возврат Цел(Задержка * Коэффициент);
	
КонецФункции

// Получает функцию обработчик из различных форматов
Функция ПолучитьФункциюОбработчик(ВыполняемыйКод)
	
	Если ТипЗнч(ВыполняемыйКод) = Тип("Строка") Тогда
		Возврат ВыполняемыйКод;
	ИначеЕсли ТипЗнч(ВыполняемыйКод) = Тип("Структура") И ВыполняемыйКод.Свойство("ИмяФункции") Тогда
		Возврат ВыполняемыйКод.ИмяФункции;
	ИначеЕсли ТипЗнч(ВыполняемыйКод) = Тип("Структура") И ВыполняемыйКод.Свойство("Процедура") Тогда
		Возврат ВыполняемыйКод;
	Иначе
		// Пытаемся вызвать как функцию
		Возврат ВыполняемыйКод;
	КонецЕсли;
	
КонецФункции

// Сохраняет текущее состояние системы перед транзакцией
Функция СохранитьСостояниеСистемы()
	
	Состояние = Новый Структура;
	
	// Сохраняем состояние объектов конфигурации
	Попытка
		// Здесь можно добавить сохранение конкретных объектов
		Состояние.Вставить("ВремяСохранения", ТекущаяДата());
		Состояние.Вставить("Пользователь", ПараметрыСеанса.ТекущийПользователь);
	Исключение
	КонецПопытки;
	
	Возврат Состояние;
	
КонецФункции

// Восстанавливает состояние системы после неудачной транзакции
Процедура ВосстановитьСостояниеСистемы(СостояниеСистемы)
	
	Попытка
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
			"Восстановление состояния системы после отката транзакции");
		
		// Здесь можно добавить логику восстановления конкретных объектов
		// Например, перезагрузка справочников, очистка кэшей и т.д.
		
		// Сбрасываем кэши
		Если Константы.ИспользоватьКэширование.Получить() Тогда
			ОчиститьВсеКэши();
		КонецЕсли;
		
	Исключение
		
		ОписаниеОшибки = ОписаниеОшибкиИнформация();
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.КритическаяОшибка, 
			СтрШаблон("Ошибка при восстановлении состояния системы: %1", ОписаниеОшибки.Описание));
			
	КонецПопытки;
	
КонецПроцедуры

// Получает состояние circuit breaker для сервиса
Функция ПолучитьСостояниеBreaker(ИмяСервиса)
	
	// В реальной системе это должно храниться в константах или регистре
	// Для демонстрации используем глобальную переменную
	Если ГлобальныеПеременные = Неопределено Тогда
		ГлобальныеПеременные = Новый Структура;
	КонецЕсли;
	
	Если НЕ ГлобальныеПеременные.Свойство("CircuitBreakerСостояния") Тогда
		ГлобальныеПеременные.Вставить("CircuitBreakerСостояния", Новый Соответствие);
	КонецЕсли;
	
	СоответствиеСостояний = ГлобальныеПеременные.CircuitBreakerСостояния;
	
	Если НЕ СоответствиеСостояний.Свойство(ИмяСервиса) Тогда
		НовоеСостояние = Новый Структура;
		НовоеСостояние.Вставить("Состояние", "CLOSED");
		НовоеСостояние.Вставить("КоличествоОшибок", 0);
		НовоеСостояние.Вставить("ВремяПоследнейОшибки", 0);
		НовоеСостояние.Вставить("ВремяПереходаВOpen", 0);
		НовоеСостояние.Вставить("КоличествоУспехов", 0);
		
		СоответствиеСостояний.Вставить(ИмяСервиса, НовоеСостояние);
	КонецЕсли;
	
	Возврат СоответствиеСостояний[ИмяСервиса];
	
КонецФункции

// Проверяет и обновляет состояние circuit breaker
Процедура ПроверитьИОбновитьСостояниеBreaker(BreakerСостояние, ПериодСекунд, TimeoutСекунд)
	
	ТекущееВремя = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Если BreakerСостояние.Состояние = "OPEN" Тогда
		
		// Проверяем, прошло ли время timeout
		Если (ТекущееВремя - BreakerСостояние.ВремяПереходаВOpen) > (TimeoutСекунд * 1000) Тогда
			BreakerСостояние.Состояние = "HALF_OPEN";
			BreakerСостояние.Вставить("КоличествоПопыток", 0);
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
				"Circuit Breaker переведен в состояние HALF_OPEN");
		КонецЕсли;
		
	ИначеЕсли BreakerСостояние.Состояние = "HALF_OPEN" Тогда
		
		// В состоянии HALF_OPEN разрешаем только одну пробную попытку
		Если BreakerСостояние.Свойство("КоличествоПопыток") И BreakerСостояние.КоличествоПопыток >= 1 Тогда
			BreakerСостояние.Состояние = "OPEN";
			BreakerСостояние.ВремяПереходаВOpen = ТекущееВремя;
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Предупреждение, 
				"Circuit Breaker переведен в состояние OPEN после неудачной HALF_OPEN попытки");
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Обрабатывает успешное выполнение в circuit breaker
Процедура ОбработатьУспехBreaker(BreakerСостояние, ЛимитОшибок)
	
	Если BreakerСостояние.Состояние = "HALF_OPEN" Тогда
		// Успешная попытка в HALF_OPEN переводит breaker в CLOSED
		BreakerСостояние.Состояние = "CLOSED";
		BreakerСостояние.Вставить("КоличествоОшибок", 0);
		BreakerСостояние.Вставить("ВремяПоследнейОшибки", 0);
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
			"Circuit Breaker переведен в состояние CLOSED после успешной HALF_OPEN попытки");
		
	ИначеЕсли BreakerСостояние.Состояние = "CLOSED" Тогда
		BreakerСостояние.Вставить("КоличествоУспехов", BreakerСостояние.КоличествоУспехов + 1);
	КонецЕсли;
	
	Если BreakerСостояние.Свойство("КоличествоПопыток") Тогда
		BreakerСостояние.Вставить("КоличествоПопыток", BreakerСостояние.КоличествоПопыток + 1);
	КонецЕсли;
	
КонецПроцедуры

// Обрабатывает ошибку в circuit breaker
Процедура ОбработатьОшибкуBreaker(BreakerСостояние, ЛимитОшибок, ОписаниеОшибки)
	
	ТекущееВремя = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Если BreakerСостояние.Состояние = "HALF_OPEN" Тогда
		// Любая ошибка в HALF_OPEN переводит breaker обратно в OPEN
		BreakerСостояние.Состояние = "OPEN";
		BreakerСостояние.ВремяПереходаВOpen = ТекущееВремя;
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Предупреждение, 
			"Circuit Breaker переведен в состояние OPEN после ошибки в HALF_OPEN");
		
	ИначеЕсли BreakerСостояние.Состояние = "CLOSED" Тогда
		
		BreakerСостояние.Вставить("КоличествоОшибок", BreakerСостояние.КоличествоОшибок + 1);
		BreakerСостояние.Вставить("ВремяПоследнейОшибки", ТекущееВремя);
		
		// Проверяем, превышен ли лимит ошибок
		Если BreakerСостояние.КоличествоОшибок >= ЛимитОшибок Тогда
			BreakerСостояние.Состояние = "OPEN";
			BreakerСостояние.ВремяПереходаВOpen = ТекущееВремя;
			
			ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.КритическаяОшибка, 
				СтрШаблон("Circuit Breaker переведен в состояние OPEN. Превышен лимит ошибок (%1)", ЛимитОшибок));
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет состояние circuit breaker
Процедура СохранитьСостояниеBreaker(ИмяСервиса, BreakerСостояние)
	
	Если ГлобальныеПеременные = Неопределено Тогда
		ГлобальныеПеременные = Новый Структура;
	КонецЕсли;
	
	Если НЕ ГлобальныеПеременные.Свойство("CircuitBreakerСостояния") Тогда
		ГлобальныеПеременные.Вставить("CircuitBreakerСостояния", Новый Соответствие);
	КонецЕсли;
	
	ГлобальныеПеременные.CircuitBreakerСостояния.Вставить(ИмяСервиса, BreakerСостояние);
	
КонецПроцедуры

// Определяет критичность операции
Функция ОпределитьКритичностьОперации(Операция)
	
	// Матрица критичности операций
	КритичностьОпераций = Новый Соответствие;
	КритичностьОпераций.Вставить("ПолучениеТоваров", 1);  // Высокая
	КритичностьОпераций.Вставить("СозданиеЗаказа", 1);    // Высокая
	КритичностьОпераций.Вставить("РасчетЦен", 2);         // Средняя
	КритичностьОпераций.Вставить("Отчеты", 3);            // Низкая
	КритичностьОпераций.Вставить("Аналитика", 4);         // Очень низкая
	
	Возврат КритичностьОпераций.Получить(Операция);
	
КонецФункции

// Получает fallback стратегию для операции
Функция ПолучитьFallbackСтратегию(Операция)
	
	FallbackСтратегии = Новый Соответствие;
	FallbackСтратегии.Вставить("ПолучениеТоваров", "Кэш");
	FallbackСтратегии.Вставить("СозданиеЗаказа", "Очередь");
	FallbackСтратегии.Вставить("РасчетЦен", "ПредыдущаяЦена");
	FallbackСтратегии.Вставить("Отчеты", "УпрощенныйОтчет");
	FallbackСтратегии.Вставить("Аналитика", "Заглушка");
	
	Возврат FallbackСтратегии.Получить(Операция);
	
КонецФункции

// Получает timeout для уровня деградации
Функция ПолучитьTimeoutДляУровня(Уровень)
	
	Timeouts = Новый Массив;
	Timeouts.Добавить(5000);   // 5 секунд - нормальный
	Timeouts.Добавить(10000);  // 10 секунд - умеренная деградация
	Timeouts.Добавить(30000);  // 30 секунд - сильная деградация
	Timeouts.Добавить(60000);  // 60 секунд - максимальная деградация
	
	Возврат ?(Уровень <Timeouts.Количество(), Timeouts[Уровень], 60000);
	
КонецФункции

// Выполняет операцию с заданным timeout
Функция ВыполнитьОперациюСTimeout(Операция, ПараметрыОперации, Timeout)
	
	Результат = Новый Структура("Успех, Результат", Ложь, Неопределено);
	
	// Создаем контекст для асинхронного выполнения
	Контекст = Новый Структура("Операция, Параметры", Операция, ПараметрыОперации);
	
	Попытка
		
		// Для демонстрации - простая имитация операции с timeout
		Если Операция = "ПолучениеТоваров" Тогда
			Результат.Результат = ПолучитьТоварыПоУмолчанию();
		ИначеЕсли Операция = "СозданиеЗаказа" Тогда
			Результат.Результат = СоздатьЗаказПоУмолчанию();
		ИначеЕсли Операция = "РасчетЦен" Тогда
			Результат.Результат = ПолучитьПредыдущиеЦены();
		Иначе
			Результат.Результат = ПолучитьЗаглушкуДляОперации(Операция);
		КонецЕсли;
		
		Результат.Успех = Истина;
		
	Исключение
		
		Результат.Успех = Ложь;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет fallback стратегию
Функция ВыполнитьFallback(Стратегия, Операция, ПараметрыОперации)
	
	Результат = Новый Структура("Успех, Результат, Сообщение", Ложь, Неопределено, "");
	
	Попытка
		
		Если Стратегия = "Кэш" Тогда
			Результат.Результат = ПолучитьКэшированныйРезультат(Операция);
			Результат.Сообщение = "Использован кэшированный результат";
			
		ИначеЕсли Стратегия = "Очередь" Тогда
			Результат.Результат = ПоставитьВОчередь(Операция, ПараметрыОперации);
			Результат.Сообщение = "Операция поставлена в очередь";
			
		ИначеЕсли Стратегия = "ПредыдущаяЦена" Тогда
			Результат.Результат = ПолучитьПредыдущиеЦены();
			Результат.Сообщение = "Использованы предыдущие цены";
			
		ИначеЕсли Стратегия = "УпрощенныйОтчет" Тогда
			Результат.Результат = ПолучитьУпрощенныйОтчет(Операция);
			Результат.Сообщение = "Сформирован упрощенный отчет";
			
		Иначе
			Результат.Результат = ПолучитьЗаглушкуДляОперации(Операция);
			Результат.Сообщение = "Использована fallback заглушка";
		КонецЕсли;
		
		Результат.Успех = (Результат.Результат <> Неопределено);
		
	Исключение
		
		Результат.Сообщение = СтрШаблон("Ошибка fallback стратегии %1: %2", 
			Стратегия, ОписаниеОшибки());
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Обновляет кэш результатов операций
Процедура ОбновитьКэшРезультатов(Операция, Результат)
	
	Если ГлобальныеПеременные = Неопределено Тогда
		ГлобальныеПеременные = Новый Структура;
	КонецЕсли;
	
	Если НЕ ГлобальныеПеременные.Свойство("КэшРезультатов") Тогда
		ГлобальныеПеременные.Вставить("КэшРезультатов", Новый Соответствие);
	КонецЕсли;
	
	КэшРезультатов = ГлобальныеПеременные.КэшРезультатов;
	
	ЭлементКэша = Новый Структура;
	ЭлементКэша.Вставить("Результат", Результат);
	ЭлементКэша.Вставить("ВремяКэширования", ТекущаяДата());
	ЭлементКэша.Вставить("СрокГодности", ТекущаяДата() + 3600); // 1 час
	
	КэшРезультатов.Вставить(Операция, ЭлементКэша);
	
КонецПроцедуры

// Получает кэшированный результат операции
Функция ПолучитьКэшированныйРезультат(Операция)
	
	Если ГлобальныеПеременные = Неопределено ИЛИ 
		НЕ ГлобальныеПеременные.Свойство("КэшРезультатов") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КэшРезультатов = ГлобальныеПеременные.КэшРезультатов;
	
	Если НЕ КэшРезультатов.Свойство(Операция) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭлементКэша = КэшРезультатов[Операция];
	
	// Проверяем срок годности
	Если ТекущаяДата() > ЭлементКэша.СрокГодности Тогда
		КэшРезультатов.Удалить(Операция);
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ЭлементКэша.Результат;
	
КонецФункции

// Уведомляет об использовании fallback
Процедура УведомитьОбИспользованииFallback(Операция, РезультатFallback)
	
	ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Предупреждение, 
		СтрШаблон("Использован fallback для операции %1: %2", 
		Операция, РезультатFallback.Сообщение));
	
	// В реальной системе здесь можно отправить уведомление администраторам
	// через электронную почту, Telegram, Slack и т.д.
	
КонецПроцедуры

#КонецОбласти

#Область ВспомогательныеФункции

// Получает информацию об ошибке
Функция ОписаниеОшибкиИнформация()
	
	СтруктураОшибки = Новый Структура("Описание, Причина, Источник, Метод", "", "", "", "");
	
	Попытка
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		
		СтруктураОшибки.Описание = ИнформацияОбОшибке.Описание;
		СтруктураОшибки.Причина = ИнформацияОбОшибке.Причина;
		СтруктураОшибки.Источник = ИнформацияОбОшибке.Источник;
		СтруктураОшибки.Метод = ИнформацияОбОшибке.Метод;
		
	Исключение
		
		СтруктураОшибки.Описание = ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат СтруктураОшибки;
	
КонецФункции

// Записывает сообщение в журнал регистрации
Процедура ЗаписатьВЖурналРегистрации(Уровень, Сообщение, ИмяСобытия = "MCP.Восстановление")
	
	Попытка
		
		ЗаписьЖурналаРегистрации(ИмяСобытия, Уровень, , , Сообщение);
		
	Исключение
		
		// Игнорируем ошибки записи в журнал
	КонецПопытки;
	
КонецПроцедуры

// Выполняет паузу на указанное количество миллисекунд
Процедура Пауза(Миллисекунды)
	
	Попытка
		
		// Используем COM-объект для создания паузы
		WScript = Новый COMОбъект("WScript.Shell");
		
		// Создаем временный файл для выполнения команды sleep
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("bat");
		
		ЗаписьТекста = Новый ЗаписьТекста(ИмяВременногоФайла, КодировкаТекста.ANSI);
		ЗаписьТекста.ЗаписатьСтроку("ping -n 1 -w " + Цел(Миллисекунды / 1000) + " 127.0.0.1 > nul");
		ЗаписьТекста.Закрыть();
		
		WScript.Run(ИмяВременногоФайла, 0, Истина);
		
		// Удаляем временный файл
		Попытка
			УдалитьФайлы(ИмяВременногоФайла);
		Исключение
		КонецПопытки;
		
	Исключение
		
		// Если не удалось создать паузу, продолжаем выполнение
	КонецПопытки;
	
КонецПроцедуры

// Вспомогательные функции для демонстрации

Функция ПолучитьТоварыПоУмолчанию()
	
	Возврат Новый ТаблицаЗначений;
	
КонецФункции

Функция СоздатьЗаказПоУмолчанию()
	
	Заказ = Новый Структура("Номер, Дата, Сумма", 
		"ЗАКАЗ-" + ФорматДата(ТекущаяДата(), "ДФ=yyyyMMddHHmmss"), 
		ТекущаяДата(), 
		0);
		
	Возврат Заказ;
	
КонецФункции

Функция ПолучитьПредыдущиеЦены()
	
	Возврат Новый Соответствие;
	
КонецФункции

Функция ПолучитьУпрощенныйОтчет(Операция)
	
	Отчет = Новый Структура;
	Отчет.Вставить("Заголовок", "Упрощенный отчет по операции: " + Операция);
	Отчет.Вставить("ДатаФормирования", ТекущаяДата());
	Отчет.Вставить("Статус", "Сформирован в режиме деградации");
	
	Возврат Отчет;
	
КонецФункции

Функция ПолучитьЗаглушкуДляОперации(Операция)
	
	Возврат СтрШаблон("Fallback результат для операции: %1", Операция);
	
КонецФункции

Функция ПоставитьВОчередь(Операция, Параметры)
	
	Очередь = Новый Структура;
	Очередь.Вставить("Идентификатор", Новый УникальныйИдентификатор);
	Очередь.Вставить("Операция", Операция);
	Очередь.Вставить("Параметры", Параметры);
	Очередь.Вставить("ДатаПостановки", ТекущаяДата());
	Очередь.Вставить("Статус", "В очереди");
	
	Возврат Очередь;
	
КонецФункции

Процедура ОчиститьВсеКэши()
	
	Попытка
		
		// Очищаем кэш метаданных
		Метаданные.Получить();
		
		// Очищаем пользовательские кэши
		Если ГлобальныеПеременные <> Неопределено Тогда
			ГлобальныеПеременные.Вставить("КэшРезультатов", Новый Соответствие);
		КонецЕсли;
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, "Кэши очищены");
		
	Исключение
		
		ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Предупреждение, 
			"Ошибка при очистке кэшей: " + ОписаниеОшибки());
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область МониторингИМетрики

// Получает метрики восстановления для указанного периода
//
// Параметры:
//   ПериодНачало - Дата - Начало периода
//   ПериодКонец - Дата - Конец периода
//   Операция - Строка - Фильтр по операции (необязательно)
//
// Возвращаемое значение:
//   Структура - Метрики восстановления
//
Функция ПолучитьМетрикиВосстановления(ПериодНачало, ПериодКонец, Операция = "") Экспорт
	
	Метрики = Новый Структура;
	Метрики.Вставить("ОбщееКоличествоПопыток", 0);
	Метрики.Вставить("УспешныеПопытки", 0);
	Метрики.Вставить("НеуспешныеПопытки", 0);
	Метрики.Вставить("СреднееВремяВосстановления", 0);
	Метрики.Вставить("ОбщееВремяВосстановления", 0);
	Метрики.Вставить("КоличествоCircuitBreaker", 0);
	Метрики.Вставить("КоличествоFallback", 0);
	
	// В реальной системе здесь должна быть выборка из журнала регистрации
	// Для демонстрации возвращаем структуру с нулевыми значениями
	
	Возврат Метрики;
	
КонецФункции

// Получает статистику circuit breaker для всех сервисов
//
// Возвращаемое значение:
//   Соответствие - Статистика по каждому сервису
//
Функция ПолучитьСтатистикуCircuitBreaker() Экспорт
	
	Статистика = Новый Соответствие;
	
	Если ГлобальныеПеременные <> Неопределено И 
		ГлобальныеПеременные.Свойство("CircuitBreakerСостояния") Тогда
		
		СоответствиеСостояний = ГлобальныеПеременные.CircuitBreakerСостояния;
		
		Для Каждого КлючЗначение Из СоответствиеСостояний Цикл
			
			Состояние = КлючЗначение.Значение;
			
			СтатистикаСервиса = Новый Структура;
			СтатистикаСервиса.Вставить("ТекущееСостояние", Состояние.Состояние);
			СтатистикаСервиса.Вставить("КоличествоОшибок", Состояние.КоличествоОшибок);
			СтатистикаСервиса.Вставить("КоличествоУспехов", Состояние.КоличествоУспехов);
			СтатистикаСервиса.Вставить("ВремяПоследнейОшибки", Состояние.ВремяПоследнейОшибки);
			
			Статистика.Вставить(КлючЗначение.Ключ, СтатистикаСервиса);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Статистика;
	
КонецФункции

// Формирует отчет о состоянии системы восстановления
//
// Параметры:
//   ВключатьДетали - Булево - Включать детальную информацию
//
// Возвращаемое значение:
//   Структура - Отчет о состоянии
//
Функция СформироватьОтчетОСостоянии(ВключатьДетали = Ложь) Экспорт
	
	Отчет = Новый Структура;
	Отчет.Вставить("ДатаФормирования", ТекущаяДата());
	Отчет.Вставить("ВерсияСистемы", "1.0");
	
	// Статистика circuit breaker
	Отчет.Вставить("CircuitBreakerСтатистика", ПолучитьСтатистикуCircuitBreaker());
	
	// Активные транзакции
	Отчет.Вставить("АктивныеТранзакции", 0); // Должно быть получено из системных переменных
	
	// Состояние кэшей
	Отчет.Вставить("СостояниеКэшей", ПолучитьСостояниеКэшей());
	
	Если ВключатьДетали Тогда
		Отчет.Вставить("ДетальнаяСтатистика", ПолучитьДетальнуюСтатистику());
	КонецЕсли;
	
	Возврат Отчет;
	
КонецФункции

// Получает состояние кэшей системы
Функция ПолучитьСостояниеКэшей()
	
	Состояние = Новый Структура;
	
	Если ГлобальныеПеременные <> Неопределено И 
		ГлобальныеПеременные.Свойство("КэшРезультатов") Тогда
		
		КэшРезультатов = ГлобальныеПеременные.КэшРезультатов;
		Состояние.Вставить("КоличествоЭлементовВКэше", КэшРезультатов.Количество());
		
		// Подсчитываем просроченные элементы
		Просроченных = 0;
		ТекущееВремя = ТекущаяДата();
		
		Для Каждого Элемент Из КэшРезультатов Цикл
			Если ТекущееВремя > Элемент.Значение.СрокГодности Тогда
				Просроченных = Просроченных + 1;
			КонецЕсли;
		КонецЦикла;
		
		Состояние.Вставить("ПросроченныхЭлементов", Просроченных);
		
	Иначе
		
		Состояние.Вставить("КоличествоЭлементовВКэше", 0);
		Состояние.Вставить("ПросроченныхЭлементов", 0);
		
	КонецЕсли;
	
	Возврат Состояние;
	
КонецФункции

// Получает детальную статистику системы
Функция ПолучитьДетальнуюСтатистику()
	
	Статистика = Новый Структура;
	
	// Здесь можно добавить более детальную статистику:
	// - История последних ошибок
	// - Время отклика операций
	// - Частота использования fallback
	// - И другие метрики
	
	Статистика.Вставить("ПоследниеОшибки", Новый Массив);
	Статистика.Вставить("СреднееВремяОтклика", 0);
	Статистика.Вставить("ЧастотаFallback", 0);
	
	Возврат Статистика;
	
КонецФункции

#КонецОбласти

#Область Инициализация

// Инициализация глобальных переменных системы восстановления
Процедура ИнициализироватьСистемуВосстановления() Экспорт
	
	Если ГлобальныеПеременные = Неопределено Тогда
		ГлобальныеПеременные = Новый Структура;
	КонецЕсли;
	
	ГлобальныеПеременные.Вставить("CircuitBreakerСостояния", Новый Соответствие);
	ГлобальныеПеременные.Вставить("КэшРезультатов", Новый Соответствие);
	ГлобальныеПеременные.Вставить("МетрикиВосстановления", Новый Структура);
	
	ЗаписатьВЖурналРегистрации(УровеньЖурналаРегистрации.Информация, 
		"Система восстановления 1С инициализирована");
	
КонецПроцедуры

#КонецОбласти
