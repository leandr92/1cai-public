"""
Документация по использованию тестов производительности 1C MCP

Включает:
- Руководство по запуску тестов
- Примеры конфигурации
- Интерпретация результатов
- Лучшие практики

Версия: 1.0.0
"""

# =============================================================================
# ИСПОЛЬЗОВАНИЕ ТЕСТОВ ПРОИЗВОДИТЕЛЬНОСТИ
# =============================================================================

"""
БЫСТРЫЙ СТАРТ

1. Установка зависимостей:
   pip install -r requirements-test.txt

2. Запуск smoke теста:
   python tests/run_performance_tests.py --smoke

3. Запуск основного набора тестов:
   python tests/run_performance_tests.py --comprehensive

4. Запуск отдельного типа тестов:
   python tests/run_performance_tests.py --load normal
   python tests/run_performance_tests.py --stress
   python tests/run_performance_tests.py --spike

ТИПЫ ТЕСТОВ ПРОИЗВОДИТЕЛЬНОСТИ

1. Load Tests (Тесты нагрузки)
   - Имитируют реальную нагрузку пользователей
   - Тестируют пропускную способность и время ответа
   - Цель: убедиться, что система работает при ожидаемой нагрузке

2. Stress Tests (Стресс-тесты)
   - Тестируют систему на грани возможностей
   - Находят точку разрушения
   - Цель: понять пределы системы

3. Endurance Tests (Тесты выносливости)
   - Тестируют длительную стабильность
   - Обнаруживают утечки памяти
   - Цель: убедиться в стабильности при длительной работе

4. Spike Tests (Тесты пиков)
   - Тестируют резкие пики нагрузки
   - Проверяют способность к восстановлению
   - Цель: убедиться в устойчивости к неожиданным нагрузкам

5. Volume Tests (Тесты объема)
   - Тестируют работу с большими объемами данных
   - Проверяют масштабируемость
   - Цель: убедиться в работе с большими наборами данных

6. Benchmark Tests (Бенчмарки)
   - Измеряют точную производительность компонентов
   - Используют pytest-benchmark
   - Цель: получить точные метрики производительности

ИНСТРУМЕНТЫ

1. pytest - основной фреймворк для тестирования
2. locust - нагрузочное тестирование HTTP
3. pytest-benchmark - микро-бенчмарки
4. memory-profiler - профилирование памяти
5. psutil - мониторинг системных ресурсов

МЕТРИКИ ПРОИЗВОДИТЕЛЬНОСТИ

Время ответа (Response Time):
- P50 (медиана) - 50% запросов быстрее этого времени
- P95 - 95% запросов быстрее этого времени
- P99 - 99% запросов быстрее этого времени

Пропускная способность (Throughput):
- RPS (Requests Per Second) - запросов в секунду
- Операций в секунду для различных типов операций

Ошибки (Errors):
- Error Rate - процент неуспешных запросов
- Success Rate - процент успешных запросов

Ресурсы:
- Memory Usage - использование памяти
- CPU Usage - использование процессора
- Disk I/O - операции ввода/вывода

ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ

Согласно стандартам производительности 1C MCP:

1. Время ответа для кэшируемых запросов: < 100ms
2. Пропускная способность: 1000+ RPS
3. Поддержка 1000+ одновременных пользователей
4. Улучшение производительности на 200-500% (по сравнению с базовой версией)
5. Стабильность при длительной работе (8+ часов)
6. Восстановление после пиков нагрузки за < 30 секунд
"""

# =============================================================================
# ПРИМЕРЫ КОНФИГУРАЦИИ
# =============================================================================

EXAMPLE_CONFIGS = {
    "development": {
        "target_host": "http://localhost:8000",
        "concurrent_users": {
            "light_load": 10,
            "normal_load": 50,
            "heavy_load": 100,
            "stress_load": 200
        },
        "test_durations": {
            "quick": "30s",
            "standard": "2m",
            "extended": "10m",
            "endurance": "30m"
        }
    },
    
    "staging": {
        "target_host": "http://staging.1c-mcp.company.com",
        "concurrent_users": {
            "light_load": 100,
            "normal_load": 500,
            "heavy_load": 1000,
            "stress_load": 2000
        },
        "test_durations": {
            "quick": "1m",
            "standard": "5m",
            "extended": "30m",
            "endurance": "2h"
        }
    },
    
    "production": {
        "target_host": "https://api.1c-mcp.company.com",
        "concurrent_users": {
            "light_load": 500,
            "normal_load": 2000,
            "heavy_load": 5000,
            "stress_load": 10000
        },
        "test_durations": {
            "quick": "2m",
            "standard": "10m",
            "extended": "1h",
            "endurance": "8h"
        }
    }
}

PERFORMANCE_THRESHOLDS = {
    "excellent": {
        "response_time_ms": {
            "cache_hit": 5,
            "cache_miss": 20,
            "api_call": 50,
            "rate_limit_check": 2
        },
        "throughput_rps": 5000,
        "error_rate_percent": 0.1,
        "concurrent_users": 10000
    },
    
    "good": {
        "response_time_ms": {
            "cache_hit": 10,
            "cache_miss": 50,
            "api_call": 100,
            "rate_limit_check": 5
        },
        "throughput_rps": 1000,
        "error_rate_percent": 1.0,
        "concurrent_users": 1000
    },
    
    "acceptable": {
        "response_time_ms": {
            "cache_hit": 50,
            "cache_miss": 100,
            "api_call": 200,
            "rate_limit_check": 10
        },
        "throughput_rps": 500,
        "error_rate_percent": 5.0,
        "concurrent_users": 500
    },
    
    "critical": {
        "response_time_ms": {
            "cache_hit": 100,
            "cache_miss": 200,
            "api_call": 500,
            "rate_limit_check": 20
        },
        "throughput_rps": 100,
        "error_rate_percent": 10.0,
        "concurrent_users": 100
    }
}

# =============================================================================
# ИНТЕРПРЕТАЦИЯ РЕЗУЛЬТАТОВ
# =============================================================================

"""
ИНТЕРПРЕТАЦИЯ РЕЗУЛЬТАТОВ ТЕСТОВ ПРОИЗВОДИТЕЛЬНОСТИ

1. ВРЕМЯ ОТВЕТА

Отличное (< 10ms):
- Система очень быстро отвечает
- Кэширование работает эффективно
- Нет узких мест в обработке запросов

Хорошее (10-50ms):
- Система отвечает быстро
- Большинство запросов обслуживается без задержек
- Допустимо для большинства приложений

Приемлемое (50-100ms):
- Заметные задержки, но терпимые
- Может влиять на UX при высокой нагрузке
- Требует оптимизации

Критическое (> 100ms):
- Серьезные проблемы с производительностью
- Требует немедленной оптимизации
- Пользователи будут испытывать дискомфорт

2. ПРОПУСКНАЯ СПОСОБНОСТЬ

Отличная (> 5000 RPS):
- Система может обрабатывать очень высокую нагрузку
- Подходит для крупных приложений
- Хороший запас производительности

Хорошая (1000-5000 RPS):
- Достаточно для большинства применений
- Можно обслуживать большое количество пользователей
- Умеренный запас производительности

Приемлемая (500-1000 RPS):
- Минимально достаточная производительность
- Может быть недостаточно при пиковых нагрузках
- Требует мониторинга

Критическая (< 500 RPS):
- Недостаточная производительность
- Приведет к проблемам при нагрузке
- Требует срочной оптимизации

3. ОШИБКИ

Отличная (< 0.1%):
- Почти все запросы обрабатываются успешно
- Высокая надежность системы
- Допустимо для критичных приложений

Хорошая (0.1-1%):
- Большинство запросов обрабатываются успешно
- Небольшое количество ошибок ожидаемо
- Приемлемо для большинства приложений

Приемлемая (1-5%):
- Заметное количество ошибок
- Может влиять на пользовательский опыт
- Требует мониторинга и улучшения

Критическая (> 5%):
- Слишком много ошибок
- Серьезные проблемы с надежностью
- Требует немедленного внимания

4. ПАМЯТЬ И РЕСУРСЫ

Рост памяти:
- Линейный рост - нормально при увеличении нагрузки
- Экспоненциальный рост - указывает на утечку памяти
- Скачки памяти - могут указывать на проблемы с GC

Использование CPU:
- < 50% - отлично, хороший запас
- 50-70% - хорошо, умеренная нагрузка
- 70-90% - приемлемо, близко к пределам
- > 90% - критично, требует оптимизации

5. СТАБИЛЬНОСТЬ

Оценка стабильности (0-100):
- 90-100: отличная стабильность
- 80-90: хорошая стабильность
- 70-80: приемлемая стабильность
- 60-70: требует внимания
- < 60: проблемы со стабильностью

Факторы стабильности:
- Постоянная производительность во времени
- Отсутствие утечек памяти
- Предсказуемое поведение при нагрузке
- Быстрое восстановление после сбоев
"""

# =============================================================================
# ЛУЧШИЕ ПРАКТИКИ
# =============================================================================

BEST_PRACTICES = """
ЛУЧШИЕ ПРАКТИКИ ТЕСТИРОВАНИЯ ПРОИЗВОДИТЕЛЬНОСТИ

1. ПЛАНИРОВАНИЕ ТЕСТОВ

- Определите целевые показатели производительности
- Выберите реалистичные сценарии использования
- Учтите пиковые нагрузки
- Планируйте тесты для различных окружений

2. ПОДГОТОВКА ОКРУЖЕНИЯ

- Используйте изолированное тестовое окружение
- Обеспечьте достаточные ресурсы (CPU, память, сеть)
- Очистите систему перед тестами
- Закройте ненужные приложения

3. ЗАПУСК ТЕСТОВ

- Начните с smoke тестов
- Постепенно увеличивайте нагрузку
- Мониторьте системные ресурсы
- Логируйте все результаты

4. АНАЛИЗ РЕЗУЛЬТАТОВ

- Сравните с целевыми показателями
- Ищите узкие места
- Анализируйте тренды
- Проверяйте стабильность

5. ОПТИМИЗАЦИЯ

- Фокусируйтесь на самых узких местах
- Тестируйте каждое изменение
- Ведите историю изменений производительности
- Документируйте улучшения

6. МОНИТОРИНГ

- Настройте непрерывный мониторинг
- Установите алерты для критических показателей
- Регулярно запускайте тесты производительности
- Отслеживайте деградацию производительности

ЧАСТЫЕ ОШИБКИ

❌ Тестирование в неподходящее время
❌ Недооценка пиковых нагрузок
❌ Игнорирование мониторинга ресурсов
❌ Отсутствие базовых метрик для сравнения
❌ Тестирование только happy path
❌ Недооценка влияния сетевых задержек
❌ Отсутствие стратегии для экстренных ситуаций

РЕКОМЕНДАЦИИ

✅ Тестируйте регулярно, а не только перед релизами
✅ Включайте тесты производительности в CI/CD
✅ Используйте реалистичные данные для тестирования
✅ Тестируйте нагрузку в разных географических регионах
✅ Моделируйте различные типы пользователей
✅ Тестируйте восстановление после сбоев
✅ Ведите базу знаний по производительности
"""

# =============================================================================
# ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
# =============================================================================

"""
ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ ТЕСТОВ ПРОИЗВОДИТЕЛЬНОСТИ

1. БЫСТРАЯ ПРОВЕРКА ПЕРЕД РЕЛИЗОМ

python tests/run_performance_tests.py --smoke
python tests/run_performance_tests.py --load normal

2. ПОЛНАЯ ПРОВЕРКА ПЕРЕД КРУПНЫМ РЕЛИЗОМ

python tests/run_performance_tests.py --comprehensive

3. ПРОВЕРКА СТАБИЛЬНОСТИ

python tests/run_performance_tests.py --endurance 120  # 2 часа

4. ТЕСТИРОВАНИЕ ПИКОВЫХ НАГРУЗОК

python tests/run_performance_tests.py --spike
python tests/run_performance_tests.py --locust stress

5. ПОИСК ПРЕДЕЛОВ СИСТЕМЫ

python tests/run_performance_tests.py --stress

6. БЕНЧМАРКИНГ КОМПОНЕНТОВ

python -m pytest tests/test_performance.py -m benchmark -v

7. ГЕНЕРАЦИЯ ОТЧЕТА

python tests/run_performance_tests.py --dashboard

8. ТЕСТИРОВАНИЕ РЕГРЕССИИ

python tests/run_performance_tests.py --regression

КОМАНДЫ ДЛЯ РАЗЛИЧНЫХ СЦЕНАРИЕВ

Разработка:
python tests/run_performance_tests.py --smoke --benchmark

Staging:
python tests/run_performance_tests.py --load normal --spike

Production-like:
python tests/run_performance_tests.py --comprehensive --endurance 480  # 8 часов

Load testing:
python tests/run_performance_tests.py --locust normal

Stress testing:
python tests/run_performance_tests.py --stress --load heavy

Регулярный мониторинг:
python tests/run_performance_tests.py --smoke --load light --dashboard

ФАЙЛЫ КОНФИГУРАЦИИ

Создайте файл performance_config.json:

{
    "test_environment": {
        "target_host": "http://localhost:8000",
        "concurrent_users": {
            "light_load": 50,
            "normal_load": 200,
            "heavy_load": 500,
            "stress_load": 1000
        }
    },
    "performance_thresholds": {
        "response_time_ms": {
            "cache_hit": 10,
            "cache_miss": 50,
            "api_call": 100
        },
        "throughput_rps": 1000,
        "error_rate_percent": 1.0
    }
}

Используйте:
python tests/run_performance_tests.py --config performance_config.json --comprehensive
"""

# =============================================================================
# TROUBLESHOOTING
# =============================================================================

TROUBLESHOOTING = """
УСТРАНЕНИЕ ПРОБЛЕМ

ПРОБЛЕМА: Тесты не запускаются

РЕШЕНИЕ:
- Проверьте установку зависимостей: pip install -r requirements-test.txt
- Убедитесь, что сервер запущен: python main.py
- Проверьте доступность порта: curl http://localhost:8000/health

ПРОБЛЕМА: Высокая задержка в тестах

Возможные причины:
- Медленное сетевое соединение
- Недостаточно ресурсов сервера
- Неоптимальные настройки кэша
- Проблемы с базой данных

РЕШЕНИЕ:
- Проверьте локальную сеть
- Мониторьте использование ресурсов
- Оптимизируйте конфигурацию системы
- Профилируйте узкие места

ПРОБЛЕМА: Память растет во время тестов

Возможные причины:
- Утечки памяти в приложении
- Неправильная работа сборщика мусора
- Кэш не очищается
- Слишком много объектов в памяти

РЕШЕНИЕ:
- Используйте memory-profiler для анализа
- Проверьте код на утечки памяти
- Настройте параметры GC
- Ограничьте размер кэша

ПРОБЛЕМА: Низкая пропускная способность

Возможные причины:
- Синхронные операции блокируют поток
- Неэффективные запросы к БД
- Слишком строгие rate limits
- Недостаточная параллелизация

РЕШЕНИЕ:
- Пересмотрите архитектуру приложения
- Оптимизируйте запросы к БД
- Настройте rate limits
- Увеличьте количество worker'ов

ПРОБЛЕМА: Много ошибок 5xx

Возможные причины:
- Перегрузка сервера
- Проблемы с зависимостями
- Некорректная обработка ошибок
- Проблемы с ресурсами

РЕШЕНИЕ:
- Уменьшите нагрузку
- Проверьте логи сервера
- Добавьте обработку ошибок
- Увеличьте ресурсы

ПРОБЛЕМА: Нестабильные результаты

Возможные причины:
- Фоновые процессы
- Проблемы с сетью
- Различная нагрузка на систему
- Нестабильные зависимости

РЕШЕНИЕ:
- Запускайте тесты в изолированной среде
- Стабилизируйте сетевое соединение
- Используйте усреднение результатов
- Фиксируйте версии зависимостей

ЛОГИ ДЛЯ ДИАГНОСТИКИ

Включите детальное логирование:

import logging
logging.basicConfig(level=logging.DEBUG)

Используйте мониторинг ресурсов:

python -c "
import psutil
import time
while True:
    print(f'CPU: {psutil.cpu_percent()}%, Memory: {psutil.virtual_memory().percent}%')
    time.sleep(1)
"

ПРОВЕРКА ПРОИЗВОДИТЕЛЬНОСТИ ОТДЕЛЬНЫХ КОМПОНЕНТОВ

Тест кэша:
python -c "
from cache import MCP_CACHE
import time
start = time.time()
for i in range(10000):
    MCP_CACHE.set(f'test_{i}', {'data': 'test'})
    MCP_CACHE.get(f'test_{i}')
print(f'Cache operations: {time.time() - start:.2f}s')

Тест rate limiting:
python -c "
from ratelimit import RateLimitManager
manager = RateLimitManager()
import time
start = time.time()
for i in range(10000):
    manager.check_rate_limit(f'user_{i}', 'default')
print(f'Rate limit checks: {time.time() - start:.2f}s')
"
"""

# =============================================================================
# ЭКСПОРТ ДЛЯ ИСПОЛЬЗОВАНИЯ
# =============================================================================

__all__ = [
    "EXAMPLE_CONFIGS",
    "PERFORMANCE_THRESHOLDS", 
    "BEST_PRACTICES",
    "TROUBLESHOOTING"
]
