input {
  # TCP input for application logs
  tcp {
    port => 5000
    codec => json
    type => "application_logs"
  }
  
  # UDP input for application logs
  udp {
    port => 5001
    codec => json
    type => "application_logs"
  }
  
  # Beats input for filebeat
  beats {
    port => 5044
    type => "beats"
  }
  
  # HTTP input for custom applications
  http {
    port => 8080
    codec => json
    type => "http_logs"
  }
}

filter {
  # Общая обработка для всех логов
  if [type] == "application_logs" or [type] == "http_logs" {
    
    # Извлечение correlation ID
    if [correlation_id] {
      mutate {
        add_field => { "trace_id" => "%{correlation_id}" }
      }
    }
    
    # Парсинг timestamp
    if [@metadata][http_method] or [@metadata][status_code] {
      date {
        match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "ISO8601" ]
        target => "@timestamp"
      }
    }
    
    # Обработка HTTP запросов
    if [level] == "request" or [message] =~ /GET|POST|PUT|DELETE/ {
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{WORD:method} %{URIPATH:path}" }
      }
    }
    
    # Извлечение информации из API Gateway
    if [service] == "api-gateway" {
      mutate {
        add_field => { "service_type" => "api-gateway" }
      }
      
      # Парсинг endpoint path
      if [path] {
        grok {
          match => { "path" => "%{GREEDYDATA:endpoint}" }
        }
      }
    }
    
    # Обработка Edge Functions логов
    if [service] =~ /edge-function/ {
      mutate {
        add_field => { "service_type" => "supabase-edge-function" }
      }
    }
    
    # Парсинг error stack traces
    if [level] == "error" and [message] {
      grok {
        match => { "message" => "(?m)%{TIMESTAMP_ISO8601:error_timestamp} %{LOGLEVEL:error_level} %{GREEDYDATA:error_message}" }
      }
    }
    
    # Добавление меток для критических событий
    if [message] =~ /CRITICAL|FATAL/ {
      mutate {
        add_tag => [ "critical" ]
      }
    }
    
    if [message] =~ /WARNING|WARN/ {
      mutate {
        add_tag => [ "warning" ]
      }
    }
    
    # Обработка JSON логов
    if [message] and [message] =~ /^\{/ {
      json {
        source => "message"
        target => "parsed_json"
      }
    }
    
    # Извлечение user_id из логов (если есть)
    if [user_id] {
      mutate {
        add_field => { "user_context" => "true" }
      }
    }
    
    # Стандартные поля для всех логов
    if ![environment] {
      mutate {
        add_field => { "environment" => "production" }
      }
    }
    
    # Парсинг request_duration для производительности
    if [request_duration] {
      ruby {
        code => "
          duration = event.get('request_duration')
          if duration
            duration_seconds = duration.to_f / 1000.0
            event.set('request_duration_seconds', duration_seconds)
          end
        "
      }
    }
  }
  
  # Обработка логов от Filebeat
  if [type] == "beats" {
    
    # Docker container logs
    if [kubernetes][container][name] {
      mutate {
        add_field => { "service" => "%{[kubernetes][container][name]}" }
      }
    }
    
    # Kubernetes pod logs
    if [kubernetes][pod][name] {
      mutate {
        add_field => { "pod_name" => "%{[kubernetes][pod][name]}" }
      }
    }
    
    # Извлечение лог уровня из Docker logs
    if [message] =~ /\bDEBUG\b/i {
      mutate { add_field => { "level" => "debug" } }
    }
    else if [message] =~ /\bINFO\b/i {
      mutate { add_field => { "level" => "info" } }
    }
    else if [message] =~ /\bWARN\b/i {
      mutate { add_field => { "level" => "warning" } }
    }
    else if [message] =~ /\bERROR\b/i {
      mutate { add_field => { "level" => "error" } }
    }
    else if [message] =~ /\bCRITICAL\b/i {
      mutate { add_field => { "level" => "critical" } }
    }
  }
  
  # Географические данные (если нужно)
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Оптимизация для производительности
  mutate {
    lowercase => [ "service", "level", "environment" ]
  }
}

output {
  # Основной output в Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    
    # Индексирование по дням для лучшей производительности
    index => "demo-ai-assistants-logs-%{+YYYY.MM.dd}"
    
    # Template для лучшей индексации
    template_name => "demo-ai-assistants-logs"
    template_pattern => "demo-ai-assistants-logs-*"
    
    # Document type (необходимо для ES 6.x, игнорируется в 7.x)
    document_type => "_doc"
    
    # Flush settings для лучшей производительности
    flush_size => 1000
    idle_flush_time => 1
  }
  
  # Отдельный индекс для ошибок
  if "error" in [level] or "critical" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "demo-ai-assistants-errors-%{+YYYY.MM.dd}"
      template_name => "demo-ai-assistants-errors"
      template_pattern => "demo-ai-assistants-errors-*"
      document_type => "_doc"
    }
  }
  
  # Отдельный индекс для критических событий
  if "critical" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "demo-ai-assistants-critical-%{+YYYY.MM.dd}"
      template_name => "demo-ai-assistants-critical"
      template_pattern => "demo-ai-assistants-critical-*"
      document_type => "_doc"
    }
    
    # Уведомления для критических событий (можно настроить webhook)
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      mapping => {
        "alerts" => [{
          "labels" => {
            "alertname" => "CriticalLogEvent"
            "severity" => "critical"
            "service" => "%{service}"
            "message" => "%{message}"
          }
        }]
      }
    }
  }
  
  # Debug output для разработки
  # stdout { codec => rubydebug }
}

# Monitoring settings
xpack.monitoring.enabled: false