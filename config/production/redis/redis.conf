# Redis Configuration for Production
# AI-ассистенты с высокой производительностью и безопасностью

################################## INCLUDES ###################################
# include /path/to/local.conf
# include /path/to/other.conf

################################## MODULES #####################################
# loadmodule /path/to/my_module.so
# loadmodule /path/to/other_module.so

################################## NETWORK #####################################
bind 0.0.0.0
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300

################################# TLS/SSL ######################################
# port 0
# tls-port 6380

# tls-cert-file redis.crt
# tls-key-file redis.key
# tls-ca-cert-file ca.crt

################################# GENERAL #####################################
daemonize no
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
logfile ""
syslog-enabled no
databases 16
always-show-logo yes

################################ SNAPSHOTTING  ################################
# Save the DB on disk:
#   save <seconds> <changes>
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
save 900 1
save 300 10
save 60 10000

stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
rdb-del-sync-files no
dir ./

################################# REPLICATION #################################
# Master-Replica replication. Use replicaof to make a Redis instance a copy of
# another Redis server. A few things to understand ASAP about Redis replication.
#
#   +------------------+      +---------------+
#   |      Master      | ---> |    Replica    |
#   | (receive writes) |      |  (exact copy) |
#   +------------------+      +---------------+
#
# 1) Redis replication is asynchronous, but you can configure a master to
#    stop accepting writes if it appears to be not connected with at least
#    a given number of replicas.
# 2) Redis replicas are able to perform a partial resynchronization with the
#    master if the replication link is lost for a relatively small amount of
#    time. You may want to configure the replication backlog size (see the next
#    sections of this file) with a reasonable value depending on your needs.
# 3) Replication is automatic and does not need user intervention. After a
#    network partition replicas automatically try to reconnected to masters
#    and resynchronize.
#
# replicaof <masterip> <masterport>

# If the master is password protected (using the "requirepass" configuration
# directive below) it is possible to tell the replica to authenticate before
# starting the replication synchronization process, otherwise the master will
# refuse the replica request.
#
# masterauth <master-password>
#
# However this is not enough if you are using Redis ACLs (for Redis version
# 6 or greater), and the default user is not capable of running the PSYNC
# command and/or other commands needed for replication. In this case it's
# better to configure a special user to use for replication with ACL
# permissions, and specify the masteruser and masteruserpass options below:
#
# masteruser <username>
# masteruserpass <password>

# When a replica loses its connection with the master, or when the replication
# is still in progress, the replica can act in two different ways:
#
# 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
#    still reply to client requests, possibly with out of date data, or the data
#    set may just be empty if this is the first synchronization.
#
# 2) if replica-serve-stale-data is set to 'no' the replica will reply with
#    error "MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'" to
#    all commands except for INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE,
#    CONFIG, DEBUG, LATENCY, PSYNC, SYNC, PFSELECT, BGREWRITEAOF, BGSAVE, SAVE, FLUSHALL,
#    FLUSHDB, LASTSAVE, KEYS, EXPIRE, TTL, TYPE, DUMP, RESTORE, INFO, SCAN, DBSIZE,
#    CONFIG SET/GET/UNSET, PING, SLOWLOG, HELP, replconf, CLIENT, CLUSTER,
#    SENTINEL, SENTINEL..., commands that would be allowed in the previous state.
#
replica-serve-stale-data yes
replica-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-diskless-load disabled
repl-ping-replica-period 10
repl-timeout 60
repl-disable-tcp-nodelay no
repl-backlog-size 1mb
repl-backlog-ttl 3600
replica-priority 100
min-replicas-to-write 0
min-replicas-max-lag 10

################################## SECURITY ###################################

# ACL categories:
# - keyspace, read, write, sortedset, list, stream, pubsub, admin, danger,
#   connection, memory, scripting, configuration, monitoring, restrict

# Require clients to issue AUTH <PASSWORD> before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
#
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it is very easy to break in.
#
# requirepass yourpassword

# Command renaming (security).
#
# It is possible to change the name of dangerous and error-prone commands, or
# hide them entirely from the default list of available commands.
#
# Example:
#
# rename-command FLUSHDB ""
# rename-command FLUSHALL ""
# rename-command KEYS ""
# rename-command CONFIG ""

################################### CLIENTS ####################################
maxclients 10000

############################## MEMORY MANAGEMENT ##############################
# Set a memory usage limit to the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys
# according to the eviction policy (maxmemory-policy).
#
# If Redis can't remove keys according to the policy, or if no policy
# is specified, Redis will start to reply with errors to commands
# that would use more memory, like SET, LPUSH, and so on, and will continue
# to reply to read-only commands like GET.
#
# This option is usually useful when using Redis as an LRU cache, or to set
# a hard memory limit for an instance (Container, Virtual Machine, etc.).
#
# WARNING: If you have replicas attached to an instance the maxmemory设置cated to the
# data, a replica may prompt for the exact memory limit (sum of main
# data + replicas output buffer) to provide the replication stream buffer
# memory, so you will need the redis output buffers and replication backlogs
# additional memory. Output buffer limits are not accounted for in total
# memory usage calculations, so you will need to account for them as well.
#
# In general have the maxmemory value to be at least 1.5 times the sum of
# the memory limits (plus the additional memory overhead).
#
# For more information about Redis memory optimization check this blog article:
# - https://redis.io/topics/memory-optimization

maxmemory 512mb
maxmemory-policy allkeys-lru
# maxmemory-policy noeviction

# DEFAULT BEHAVIOUR:
# volatile-lru -> Evict using approximated LRU, only keys with an expire set.
# allkeys-lru -> Evict any key using approximated LRU.
# volatile-lfu -> Evict using approximated LFU, only keys with an expire set.
# allkeys-lfu -> Evict any key using approximated LFU.
# volatile-random -> Remove a random key having an expire set.
# allkeys-random -> Remove a random key, any key.
# volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
# noeviction -> Don't evict anything, just return an error on write operations.

############################# LAZY FREEING ####################################
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

############################## APPEND ONLY MODE ###############################
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble yes

################################ LUA SCRIPTING  ###############################
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################
# Normal Redis instances can't be part of a cluster; nodes with 0 are ignored.
# Cluster is only for 127.0.0.1:6379 by default.
# cluster-enabled yes
# cluster-config-file nodes-6379.conf
# cluster-node-timeout 15000
# cluster-replica-validity-factor 10
# cluster-migration-barrier 1
# cluster-require-full-coverage yes

################################## SLOW LOG ###################################
# The Redis Slow Log is a system that log queries that exceeded a specified
# execution time. The execution time does not include the I/O operations
# like talking with the client, sending the reply and so forth, but only the
# time needed to actually execute the command (this is the only stage of
# command execution where the thread is blocked and can not serve other
# requests in the meantime).
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed, in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.

slowlog-log-slower-than 10000
slowlog-max-len 128

################################ LATENCY MONITOR ##############################
# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
#
# Via the LATENCY command this information is available to the user that can
# print graphs and obtain reports.
#
# This system is disabled by default as it is mostly not needed if you
# don't have latency issues, and the data have a good overhead but a cost
# some CPU cycles.
#
# latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################
# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at https://redis.io/topics/notifications
#
# For instance if keyspace events notification is enabled, and a client
# performs a DEL operation on key "foo" stored in the Database 0, two
# messages will be published via Pub/Sub:
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
#
#  K     Keyspace events, published with __keyspace@<db>__ prefix.
#  E     Keyevent events, published with __keyevent@<db>__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events
#  e     Evicted events
#  A     Alias for "g$lshzxe", so that the string means all the events.
#
#  The string "AKE" means all the events.
#
#  The empty string means no notifications.
#
#  Example: to enable list and generic events, from the point of view of the
#  name of the event, use:
#
#  notify-keyspace-events Elg
#
#  Example 2: to receive the expired and evicted events, use:
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. By default only
#  notifications are enabled.

notify-keyspace-events ""

############################### ADVANCED CONFIG #############################
# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following
# directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Lists are also encoded in a special way to save a lot of space.
# The number of entries per list with pop/push operations can be tuned
# to optimize memory usage.
list-max-ziplist-size -2
list-compress-depth 0

# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in decimal range with a
# maximum of 64 bit signed integers.
#
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length
# and elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When a HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~3000 in order to have the benefits of the sparse
# representation while still being better for memory footprint.
hll-sparse-max-bytes 3000

# Stream large node max value / items. The stream data structure is a
# radix tree of big nodes that encode multiple items inside them.
# The following max bytes/bytes estimate the tree node size.
# Once a node grows over this size the stream is encoded as a list of
# micro-list sub-nodes.
#
# The exact memory vs CPU trade-off is: big_nodes_len <= stream-node-max-bytes
# means nodes are encoded as a list of micro-batches items of length
# stream-node-max-entries. Configuring either config to 0 disables the node.
stream-node-max-bytes 4096
stream-node-max-entries 100

# Activating actives defrag. By default this is disabled, in order to make
# sure that Redis was not build with this feature enabled by default, or
# if you run a different key from the one that is not a valid format, it
# will silently ignore it.
#
# Yes defrag should be disabled if not needed.
# activedefrag no

# Active defrag process will try to defrag whenever a big amount of memory
# is moved. For this to work we need some stats, and this is what the
# /proc/sys/vm/stat_interval provides. We use this information to trigger
# the defrag process.
#
# The default is 10 seconds, to run the defrag process.
# active-defrag-ignore-bytes 100mb
# Minimum percentage of fragmented space before starting active defrag
# active-defrag-threshold-lower 10
# Maximum percentage of fragmented space before skipping active defrag
# active-defrag-threshold-upper 100
# Maximum effort for defrag CPU usage
# active-defrag-cycle-min 5
# Maximum defrag CPU usage percentage
# active-defrag-cycle-max 75

################################## MODULES #####################################
# Load modules at startup. If the server is not able to load modules
# it will abort. You can use commas separated filenames to load multiple
# modules.
#
# loadmodule /path/to/my_module.so
#
# loadmodule /path/to/other_module.so

################################## INCLUDES ###################################
# Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis servers but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
#
# include /path/to/local.conf
# include /path/to/other.conf